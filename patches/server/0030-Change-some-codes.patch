From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Sun, 30 Oct 2022 19:54:09 +0800
Subject: [PATCH] Change some codes


diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java
new file mode 100644
index 0000000000000000000000000000000000000000..67dd5fe624fe4428d8907000cb23a33485fd6bd9
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java
@@ -0,0 +1,41 @@
+package net.himeki.mcmtfabric.parallelised;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+
+public class ConcurrentCollections {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public static <T> Set<T> newHashSet() {
+        //LOGGER.info("Concurrent hash set created");
+        return Collections.newSetFromMap(new ConcurrentHashMap<T, Boolean>());
+    }
+
+    public static <T, U> Map<T, U> newHashMap() {
+        //LOGGER.info("Concurrent hash map created");
+        return new ConcurrentHashMap<T, U>();
+    }
+
+    public static <T> List<T> newLinkedList() {
+        LOGGER.info("Concurrent \"linked\" list created");
+        return new CopyOnWriteArrayList<T>();
+    }
+
+    public static <T> Collector<T, ?, List<T>> toList() {
+        return Collectors.toCollection(CopyOnWriteArrayList::new);
+    }
+
+    public static <T> Queue<T> newArrayDeque() {
+        LOGGER.info("Concurrent \"array\" deque created");
+        return new ConcurrentLinkedDeque<T>();
+    }
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..22b9d217dc06caaf8fbec21f0e31aa1cd13144ee
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java
@@ -0,0 +1,945 @@
+package net.himeki.mcmtfabric.parallelised;
+
+/*
+ * From: http://www.java2s.com/Code/Java/Collections-Data-Structure/ConcurrentDoublyLinkedList.htm
+ *
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/licenses/publicdomain
+ *
+ * Modified to actually implement List<E>
+ */
+
+import java.util.AbstractCollection;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.commons.lang3.NotImplementedException;
+
+/**
+ * A concurrent linked-list implementation of a {@link Deque} (double-ended
+ * queue). Concurrent insertion, removal, and access operations execute safely
+ * across multiple threads. Iterators are <i>weakly consistent</i>, returning
+ * elements reflecting the state of the deque at some point at or since the
+ * creation of the iterator. They do <em>not</em> throw
+ * {@link ConcurrentModificationException}, and may proceed concurrently with
+ * other operations.
+ *
+ * <p>
+ * This class and its iterators implement all of the <em>optional</em> methods
+ * of the {@link Collection} and {@link Iterator} interfaces. Like most other
+ * concurrent collection implementations, this class does not permit the use of
+ * <tt>null</tt> elements. because some null arguments and return values cannot
+ * be reliably distinguished from the absence of elements. Arbitrarily, the
+ * {@link Collection#remove} method is mapped to <tt>removeFirstOccurrence</tt>,
+ * and {@link Collection#add} is mapped to <tt>addLast</tt>.
+ *
+ * <p>
+ * Beware that, unlike in most collections, the <tt>size</tt> method is
+ * <em>NOT</em> a constant-time operation. Because of the asynchronous nature of
+ * these deques, determining the current number of elements requires a traversal
+ * of the elements.
+ *
+ * <p>
+ * This class is <tt>Serializable</tt>, but relies on default serialization
+ * mechanisms. Usually, it is a better idea for any serializable class using a
+ * <tt>ConcurrentLinkedDeque</tt> to instead serialize a snapshot of the
+ * elements obtained by method <tt>toArray</tt>.
+ *
+ * @author Doug Lea
+ * @param <E> the type of elements held in this collection
+ */
+
+public class ConcurrentDoublyLinkedList<E> extends AbstractCollection<E> implements List<E>, java.io.Serializable {
+
+    /*
+     * This is an adaptation of an algorithm described in Paul Martin's "A Practical
+     * Lock-Free Doubly-Linked List". Sun Labs Tech report. The basic idea is to
+     * primarily rely on next-pointers to ensure consistency. Prev-pointers are in
+     * part optimistic, reconstructed using forward pointers as needed. The main
+     * forward list uses a variant of HM-list algorithm similar to the one used in
+     * ConcurrentSkipListMap class, but a little simpler. It is also basically
+     * similar to the approach in Edya Ladan-Mozes and Nir Shavit "An Optimistic
+     * Approach to Lock-Free FIFO Queues" in DISC04.
+     *
+     * Quoting a summary in Paul Martin's tech report:
+     *
+     * All cleanups work to maintain these invariants: (1) forward pointers are the
+     * ground truth. (2) forward pointers to dead nodes can be improved by swinging
+     * them further forward around the dead node. (2.1) forward pointers are still
+     * correct when pointing to dead nodes, and forward pointers from dead nodes are
+     * left as they were when the node was deleted. (2.2) multiple dead nodes may
+     * point forward to the same node. (3) backward pointers were correct when they
+     * were installed (3.1) backward pointers are correct when pointing to any node
+     * which points forward to them, but since more than one forward pointer may
+     * point to them, the live one is best. (4) backward pointers that are out of
+     * date due to deletion point to a deleted node, and need to point further back
+     * until they point to the live node that points to their source. (5) backward
+     * pointers that are out of date due to insertion point too far backwards, so
+     * shortening their scope (by searching forward) fixes them. (6) backward
+     * pointers from a dead node cannot be "improved" since there may be no live
+     * node pointing forward to their origin. (However, it does no harm to try to
+     * improve them while racing with a deletion.)
+     *
+     *
+     * Notation guide for local variables n, b, f : a node, its predecessor, and
+     * successor s : some other successor
+     */
+
+    // Minor convenience utilities
+
+    /**
+     * Returns true if given reference is non-null and isn't a header, trailer, or
+     * marker.
+     *
+     * @param n (possibly null) node
+     * @return true if n exists as a user node
+     */
+    private static boolean usable(Node<?> n) {
+        return n != null && !n.isSpecial();
+    }
+
+    /**
+     * Throws NullPointerException if argument is null
+     *
+     * @param v the element
+     */
+    private static void checkNullArg(Object v) {
+        if (v == null)
+            throw new NullPointerException();
+    }
+
+    /**
+     * Returns element unless it is null, in which case throws
+     * NoSuchElementException.
+     *
+     * @param v the element
+     * @return the element
+     */
+    private E screenNullResult(E v) {
+        if (v == null)
+            throw new NoSuchElementException();
+        return v;
+    }
+
+    /**
+     * Creates an array list and fills it with elements of this list. Used by
+     * toArray.
+     *
+     * @return the arrayList
+     */
+    private ArrayList<E> toArrayList() {
+        ArrayList<E> c = new ArrayList<E>();
+        for (Node<E> n = header.forward(); n != null; n = n.forward())
+            c.add(n.element);
+        return c;
+    }
+
+    // Fields and constructors
+
+    private static final long serialVersionUID = 876323262645176354L;
+
+    /**
+     * List header. First usable node is at header.forward().
+     */
+    private final Node<E> header;
+
+    /**
+     * List trailer. Last usable node is at trailer.back().
+     */
+    private final Node<E> trailer;
+
+    /**
+     * Constructs an empty deque.
+     */
+    public ConcurrentDoublyLinkedList() {
+        Node<E> h = new Node<E>(null, null, null);
+        Node<E> t = new Node<E>(null, null, h);
+        h.setNext(t);
+        header = h;
+        trailer = t;
+    }
+
+    /**
+     * Constructs a deque containing the elements of the specified collection, in
+     * the order they are returned by the collection's iterator.
+     *
+     * @param c the collection whose elements are to be placed into this deque.
+     * @throws NullPointerException if <tt>c</tt> or any element within it is
+     *                              <tt>null</tt>
+     */
+    public ConcurrentDoublyLinkedList(Collection<? extends E> c) {
+        this();
+        addAll(c);
+    }
+
+    /**
+     * Prepends the given element at the beginning of this deque.
+     *
+     * @param o the element to be inserted at the beginning of this deque.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public void addFirst(E o) {
+        checkNullArg(o);
+        while (header.append(o) == null)
+            ;
+    }
+
+    /**
+     * Appends the given element to the end of this deque. This is identical in
+     * function to the <tt>add</tt> method.
+     *
+     * @param o the element to be inserted at the end of this deque.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public void addLast(E o) {
+        checkNullArg(o);
+        while (trailer.prepend(o) == null)
+            ;
+    }
+
+    /**
+     * Prepends the given element at the beginning of this deque.
+     *
+     * @param o the element to be inserted at the beginning of this deque.
+     * @return <tt>true</tt> always
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean offerFirst(E o) {
+        addFirst(o);
+        return true;
+    }
+
+    /**
+     * Appends the given element to the end of this deque. (Identical in function to
+     * the <tt>add</tt> method; included only for consistency.)
+     *
+     * @param o the element to be inserted at the end of this deque.
+     * @return <tt>true</tt> always
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean offerLast(E o) {
+        addLast(o);
+        return true;
+    }
+
+    /**
+     * Retrieves, but does not remove, the first element of this deque, or returns
+     * null if this deque is empty.
+     *
+     * @return the first element of this queue, or <tt>null</tt> if empty.
+     */
+    public E peekFirst() {
+        Node<E> n = header.successor();
+        return (n == null) ? null : n.element;
+    }
+
+    /**
+     * Retrieves, but does not remove, the last element of this deque, or returns
+     * null if this deque is empty.
+     *
+     * @return the last element of this deque, or <tt>null</tt> if empty.
+     */
+    public E peekLast() {
+        Node<E> n = trailer.predecessor();
+        return (n == null) ? null : n.element;
+    }
+
+    /**
+     * Returns the first element in this deque.
+     *
+     * @return the first element in this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E getFirst() {
+        return screenNullResult(peekFirst());
+    }
+
+    /**
+     * Returns the last element in this deque.
+     *
+     * @return the last element in this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E getLast() {
+        return screenNullResult(peekLast());
+    }
+
+    /**
+     * Retrieves and removes the first element of this deque, or returns null if
+     * this deque is empty.
+     *
+     * @return the first element of this deque, or <tt>null</tt> if empty.
+     */
+    public E pollFirst() {
+        for (;;) {
+            Node<E> n = header.successor();
+            if (!usable(n))
+                return null;
+            if (n.delete())
+                return n.element;
+        }
+    }
+
+    /**
+     * Retrieves and removes the last element of this deque, or returns null if this
+     * deque is empty.
+     *
+     * @return the last element of this deque, or <tt>null</tt> if empty.
+     */
+    public E pollLast() {
+        for (;;) {
+            Node<E> n = trailer.predecessor();
+            if (!usable(n))
+                return null;
+            if (n.delete())
+                return n.element;
+        }
+    }
+
+    /**
+     * Removes and returns the first element from this deque.
+     *
+     * @return the first element from this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E removeFirst() {
+        return screenNullResult(pollFirst());
+    }
+
+    /**
+     * Removes and returns the last element from this deque.
+     *
+     * @return the last element from this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E removeLast() {
+        return screenNullResult(pollLast());
+    }
+
+    // *** Queue and stack methods ***
+    public boolean offer(E e) {
+        return offerLast(e);
+    }
+
+    public boolean add(E e) {
+        return offerLast(e);
+    }
+
+    public E poll() {
+        return pollFirst();
+    }
+
+    public E remove() {
+        return removeFirst();
+    }
+
+    public E peek() {
+        return peekFirst();
+    }
+
+    public E element() {
+        return getFirst();
+    }
+
+    public void push(E e) {
+        addFirst(e);
+    }
+
+    public E pop() {
+        return removeFirst();
+    }
+
+    /**
+     * Removes the first element <tt>e</tt> such that <tt>o.equals(e)</tt>, if such
+     * an element exists in this deque. If the deque does not contain the element,
+     * it is unchanged.
+     *
+     * @param o element to be removed from this deque, if present.
+     * @return <tt>true</tt> if the deque contained the specified element.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean removeFirstOccurrence(Object o) {
+        checkNullArg(o);
+        for (;;) {
+            Node<E> n = header.forward();
+            for (;;) {
+                if (n == null)
+                    return false;
+                if (o.equals(n.element)) {
+                    if (n.delete())
+                        return true;
+                    else
+                        break; // restart if interference
+                }
+                n = n.forward();
+            }
+        }
+    }
+
+    /**
+     * Removes the last element <tt>e</tt> such that <tt>o.equals(e)</tt>, if such
+     * an element exists in this deque. If the deque does not contain the element,
+     * it is unchanged.
+     *
+     * @param o element to be removed from this deque, if present.
+     * @return <tt>true</tt> if the deque contained the specified element.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean removeLastOccurrence(Object o) {
+        checkNullArg(o);
+        for (;;) {
+            Node<E> s = trailer;
+            for (;;) {
+                Node<E> n = s.back();
+                if (s.isDeleted() || (n != null && n.successor() != s))
+                    break; // restart if pred link is suspect.
+                if (n == null)
+                    return false;
+                if (o.equals(n.element)) {
+                    if (n.delete())
+                        return true;
+                    else
+                        break; // restart if interference
+                }
+                s = n;
+            }
+        }
+    }
+
+    /**
+     * Returns <tt>true</tt> if this deque contains at least one element <tt>e</tt>
+     * such that <tt>o.equals(e)</tt>.
+     *
+     * @param o element whose presence in this deque is to be tested.
+     * @return <tt>true</tt> if this deque contains the specified element.
+     */
+    public boolean contains(Object o) {
+        if (o == null)
+            return false;
+        for (Node<E> n = header.forward(); n != null; n = n.forward())
+            if (o.equals(n.element))
+                return true;
+        return false;
+    }
+
+    /**
+     * Returns <tt>true</tt> if this collection contains no elements.
+     * <p>
+     *
+     * @return <tt>true</tt> if this collection contains no elements.
+     */
+    public boolean isEmpty() {
+        return !usable(header.successor());
+    }
+
+    /**
+     * Returns the number of elements in this deque. If this deque contains more
+     * than <tt>Integer.MAX_VALUE</tt> elements, it returns
+     * <tt>Integer.MAX_VALUE</tt>.
+     *
+     * <p>
+     * Beware that, unlike in most collections, this method is <em>NOT</em> a
+     * constant-time operation. Because of the asynchronous nature of these deques,
+     * determining the current number of elements requires traversing them all to
+     * count them. Additionally, it is possible for the size to change during
+     * execution of this method, in which case the returned result will be
+     * inaccurate. Thus, this method is typically not very useful in concurrent
+     * applications.
+     *
+     * @return the number of elements in this deque.
+     */
+    public int size() {
+        long count = 0;
+        for (Node<E> n = header.forward(); n != null; n = n.forward())
+            ++count;
+        return (count >= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) count;
+    }
+
+    /**
+     * Removes the first element <tt>e</tt> such that <tt>o.equals(e)</tt>, if such
+     * an element exists in this deque. If the deque does not contain the element,
+     * it is unchanged.
+     *
+     * @param o element to be removed from this deque, if present.
+     * @return <tt>true</tt> if the deque contained the specified element.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean remove(Object o) {
+        return removeFirstOccurrence(o);
+    }
+
+    /**
+     * Appends all of the elements in the specified collection to the end of this
+     * deque, in the order that they are returned by the specified collection's
+     * iterator. The behavior of this operation is undefined if the specified
+     * collection is modified while the operation is in progress. (This implies that
+     * the behavior of this call is undefined if the specified Collection is this
+     * deque, and this deque is nonempty.)
+     *
+     * @param c the elements to be inserted into this deque.
+     * @return <tt>true</tt> if this deque changed as a result of the call.
+     * @throws NullPointerException if <tt>c</tt> or any element within it is
+     *                              <tt>null</tt>
+     */
+    public boolean addAll(Collection<? extends E> c) {
+        Iterator<? extends E> it = c.iterator();
+        if (!it.hasNext())
+            return false;
+        do {
+            addLast(it.next());
+        } while (it.hasNext());
+        return true;
+    }
+
+    /**
+     * Removes all of the elements from this deque.
+     */
+    public void clear() {
+        while (pollFirst() != null)
+            ;
+    }
+
+    /**
+     * Returns an array containing all of the elements in this deque in the correct
+     * order.
+     *
+     * @return an array containing all of the elements in this deque in the correct
+     *         order.
+     */
+    public Object[] toArray() {
+        return toArrayList().toArray();
+    }
+
+    /**
+     * Returns an array containing all of the elements in this deque in the correct
+     * order; the runtime type of the returned array is that of the specified array.
+     * If the deque fits in the specified array, it is returned therein. Otherwise,
+     * a new array is allocated with the runtime type of the specified array and the
+     * size of this deque.
+     * <p>
+     *
+     * If the deque fits in the specified array with room to spare (i.e., the array
+     * has more elements than the deque), the element in the array immediately
+     * following the end of the collection is set to null. This is useful in
+     * determining the length of the deque <i>only</i> if the caller knows that the
+     * deque does not contain any null elements.
+     *
+     * @param a the array into which the elements of the deque are to be stored, if
+     *          it is big enough; otherwise, a new array of the same runtime type is
+     *          allocated for this purpose.
+     * @return an array containing the elements of the deque.
+     * @throws ArrayStoreException  if the runtime type of a is not a supertype of
+     *                              the runtime type of every element in this deque.
+     * @throws NullPointerException if the specified array is null.
+     */
+    public <T> T[] toArray(T[] a) {
+        return toArrayList().toArray(a);
+    }
+
+    /**
+     * Returns a weakly consistent iterator over the elements in this deque, in
+     * first-to-last order. The <tt>next</tt> method returns elements reflecting the
+     * state of the deque at some point at or since the creation of the iterator.
+     * The method does <em>not</em> throw {@link ConcurrentModificationException},
+     * and may proceed concurrently with other operations.
+     *
+     * @return an iterator over the elements in this deque
+     */
+    public Iterator<E> iterator() {
+        return new CLDIterator();
+    }
+
+    final class CLDIterator implements Iterator<E> {
+        Node<E> last;
+
+        Node<E> next = header.forward();
+
+        public boolean hasNext() {
+            return next != null;
+        }
+
+        public E next() {
+            Node<E> l = last = next;
+            if (l == null)
+                throw new NoSuchElementException();
+            next = next.forward();
+            return l.element;
+        }
+
+        public void remove() {
+            Node<E> l = last;
+            if (l == null)
+                throw new IllegalStateException();
+            while (!l.delete() && !l.isDeleted())
+                ;
+        }
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends E> c) {
+        throw new NotImplementedException("TODO");
+    }
+
+    @Override
+    public E get(int index) {
+        Node<E> current = header.successor();
+        if (current == null) {
+            throw new IndexOutOfBoundsException();
+        }
+        for (; index > 0; index --) {
+            current = current.successor();
+            if (current == null) {
+                throw new IndexOutOfBoundsException();
+            }
+        }
+        return current.element;
+    }
+
+    @Override
+    public E set(int index, E element) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public void add(int index, E element) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public E remove(int index) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public ListIterator<E> listIterator() {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public ListIterator<E> listIterator(int index) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public List<E> subList(int fromIndex, int toIndex) {
+        throw new NotImplementedException("INVALID");
+    }
+
+}
+
+/**
+ * Linked Nodes. As a minor efficiency hack, this class opportunistically
+ * inherits from AtomicReference, with the atomic ref used as the "next" link.
+ *
+ * Nodes are in doubly-linked lists. There are three kinds of special nodes,
+ * distinguished by: * The list header has a null prev link * The list trailer
+ * has a null next link * A deletion marker has a prev link pointing to itself.
+ * All three kinds of special nodes have null element fields.
+ *
+ * Regular nodes have non-null element, next, and prev fields. To avoid visible
+ * inconsistencies when deletions overlap element replacement, replacements are
+ * done by replacing the node, not just setting the element.
+ *
+ * Nodes can be traversed by read-only ConcurrentLinkedDeque class operations
+ * just by following raw next pointers, so long as they ignore any special nodes
+ * seen along the way. (This is automated in method forward.) However, traversal
+ * using prev pointers is not guaranteed to see all live nodes since a prev
+ * pointer of a deleted node can become unrecoverably stale.
+ */
+
+class Node<E> extends AtomicReference<Node<E>> {
+
+    private static final long serialVersionUID = 6640557564507962862L;
+
+    private volatile Node<E> prev;
+
+    final E element;
+
+    /** Creates a node with given contents */
+    Node(E element, Node<E> next, Node<E> prev) {
+        super(next);
+        this.prev = prev;
+        this.element = element;
+    }
+
+    /** Creates a marker node with given successor */
+    Node(Node<E> next) {
+        super(next);
+        this.prev = this;
+        this.element = null;
+    }
+
+    /**
+     * Gets next link (which is actually the value held as atomic reference).
+     */
+    private Node<E> getNext() {
+        return get();
+    }
+
+    /**
+     * Sets next link
+     *
+     * @param n the next node
+     */
+    void setNext(Node<E> n) {
+        set(n);
+    }
+
+    /**
+     * compareAndSet next link
+     */
+    private boolean casNext(Node<E> cmp, Node<E> val) {
+        return compareAndSet(cmp, val);
+    }
+
+    /**
+     * Gets prev link
+     */
+    private Node<E> getPrev() {
+        return prev;
+    }
+
+    /**
+     * Sets prev link
+     *
+     * @param b the previous node
+     */
+    void setPrev(Node<E> b) {
+        prev = b;
+    }
+
+    /**
+     * Returns true if this is a header, trailer, or marker node
+     */
+    boolean isSpecial() {
+        return element == null;
+    }
+
+    /**
+     * Returns true if this is a trailer node
+     */
+    boolean isTrailer() {
+        return getNext() == null;
+    }
+
+    /**
+     * Returns true if this is a header node
+     */
+    boolean isHeader() {
+        return getPrev() == null;
+    }
+
+    /**
+     * Returns true if this is a marker node
+     */
+    boolean isMarker() {
+        return getPrev() == this;
+    }
+
+    /**
+     * Returns true if this node is followed by a marker, meaning that it is
+     * deleted.
+     *
+     * @return true if this node is deleted
+     */
+    boolean isDeleted() {
+        Node<E> f = getNext();
+        return f != null && f.isMarker();
+    }
+
+    /**
+     * Returns next node, ignoring deletion marker
+     */
+    private Node<E> nextNonmarker() {
+        Node<E> f = getNext();
+        return (f == null || !f.isMarker()) ? f : f.getNext();
+    }
+
+    /**
+     * Returns the next non-deleted node, swinging next pointer around any
+     * encountered deleted nodes, and also patching up successor''s prev link to
+     * point back to this. Returns null if this node is trailer so has no successor.
+     *
+     * @return successor, or null if no such
+     */
+    Node<E> successor() {
+        Node<E> f = nextNonmarker();
+        for (;;) {
+            if (f == null)
+                return null;
+            if (!f.isDeleted()) {
+                if (f.getPrev() != this && !isDeleted())
+                    f.setPrev(this); // relink f's prev
+                return f;
+            }
+            Node<E> s = f.nextNonmarker();
+            if (f == getNext())
+                casNext(f, s); // unlink f
+            f = s;
+        }
+    }
+
+    /**
+     * Returns the apparent predecessor of target by searching forward for it
+     * starting at this node, patching up pointers while traversing. Used by
+     * predecessor().
+     *
+     * @return target's predecessor, or null if not found
+     */
+    private Node<E> findPredecessorOf(Node<E> target) {
+        Node<E> n = this;
+        for (;;) {
+            Node<E> f = n.successor();
+            if (f == target)
+                return n;
+            if (f == null)
+                return null;
+            n = f;
+        }
+    }
+
+    /**
+     * Returns the previous non-deleted node, patching up pointers as needed.
+     * Returns null if this node is header so has no successor. May also return null
+     * if this node is deleted, so doesn't have a distinct predecessor.
+     *
+     * @return predecessor or null if not found
+     */
+    Node<E> predecessor() {
+        Node<E> n = this;
+        for (;;) {
+            Node<E> b = n.getPrev();
+            if (b == null)
+                return n.findPredecessorOf(this);
+            Node<E> s = b.getNext();
+            if (s == this)
+                return b;
+            if (s == null || !s.isMarker()) {
+                Node<E> p = b.findPredecessorOf(this);
+                if (p != null)
+                    return p;
+            }
+            n = b;
+        }
+    }
+
+    /**
+     * Returns the next node containing a nondeleted user element. Use for forward
+     * list traversal.
+     *
+     * @return successor, or null if no such
+     */
+    Node<E> forward() {
+        Node<E> f = successor();
+        return (f == null || f.isSpecial()) ? null : f;
+    }
+
+    /**
+     * Returns previous node containing a nondeleted user element, if possible. Use
+     * for backward list traversal, but beware that if this method is called from a
+     * deleted node, it might not be able to determine a usable predecessor.
+     *
+     * @return predecessor, or null if no such could be found
+     */
+    Node<E> back() {
+        Node<E> f = predecessor();
+        return (f == null || f.isSpecial()) ? null : f;
+    }
+
+    /**
+     * Tries to insert a node holding element as successor, failing if this node is
+     * deleted.
+     *
+     * @param element the element
+     * @return the new node, or null on failure.
+     */
+    Node<E> append(E element) {
+        for (;;) {
+            Node<E> f = getNext();
+            if (f == null || f.isMarker())
+                return null;
+            Node<E> x = new Node<E>(element, f, this);
+            if (casNext(f, x)) {
+                f.setPrev(x); // optimistically link
+                return x;
+            }
+        }
+    }
+
+    /**
+     * Tries to insert a node holding element as predecessor, failing if no live
+     * predecessor can be found to link to.
+     *
+     * @param element the element
+     * @return the new node, or null on failure.
+     */
+    Node<E> prepend(E element) {
+        for (;;) {
+            Node<E> b = predecessor();
+            if (b == null)
+                return null;
+            Node<E> x = new Node<E>(element, this, b);
+            if (b.casNext(this, x)) {
+                setPrev(x); // optimistically link
+                return x;
+            }
+        }
+    }
+
+    /**
+     * Tries to mark this node as deleted, failing if already deleted or if this
+     * node is header or trailer
+     *
+     * @return true if successful
+     */
+    boolean delete() {
+        Node<E> b = getPrev();
+        Node<E> f = getNext();
+        if (b != null && f != null && !f.isMarker() && casNext(f, new Node<E>(f))) {
+            if (b.casNext(this, f))
+                f.setPrev(b);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Tries to insert a node holding element to replace this node. failing if
+     * already deleted.
+     *
+     * @param newElement the new element
+     * @return the new node, or null on failure.
+     */
+    Node<E> replace(E newElement) {
+        for (;;) {
+            Node<E> b = getPrev();
+            Node<E> f = getNext();
+            if (b == null || f == null || f.isMarker())
+                return null;
+            Node<E> x = new Node<E>(newElement, f, b);
+            if (casNext(f, new Node<E>(x))) {
+                b.successor(); // to relink b
+                x.successor(); // to relink f
+                return x;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a9cac8aa72f4dbdaefbfa17584525955ba1b9b0
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java
@@ -0,0 +1,237 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+import it.unimi.dsi.fastutil.longs.LongArrays;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import it.unimi.dsi.fastutil.longs.LongComparator;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongIterators;
+import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongListIterator;
+import it.unimi.dsi.fastutil.longs.LongSortedSet;
+
+public class ConcurrentLongLinkedOpenHashSet extends LongLinkedOpenHashSet {
+
+    private static final long serialVersionUID = -5532128240738069111L;
+
+    private final ConcurrentSkipListSet<Long> backing= new ConcurrentSkipListSet<Long>();
+
+    public ConcurrentLongLinkedOpenHashSet() {
+        //backing = new ConcurrentLinkedDeque<Long>();
+        //backing = new ConcurrentSkipListSet<Long>();
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final int initial) {
+        //backing = new ConcurrentLinkedDeque<Long>();
+        //backing = new ConcurrentSkipListSet<Long>();
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final int initial, final float dnc) {
+        this(initial);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongCollection c) {
+        this(c.size());
+        addAll(c);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongCollection c, final float f) {
+        this(c.size(), f);
+        addAll(c);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongIterator i, final float f) {
+        this(16, f);
+        while (i.hasNext())
+            add(i.nextLong());
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongIterator i) {
+        this(i, -1);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final Iterator<?> i, final float f) {
+        this(LongIterators.asLongIterator(i), f);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final Iterator<?> i) {
+        this(LongIterators.asLongIterator(i));
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final int offset, final int length, final float f) {
+        this(length < 0 ? 0 : length, f);
+        LongArrays.ensureOffsetLength(a, offset, length);
+        for (int i = 0; i < length; i++)
+            add(a[offset + i]);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final int offset, final int length) {
+        this(a, offset, length, DEFAULT_LOAD_FACTOR);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final float f) {
+        this(a, 0, a.length, f);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a) {
+        this(a, -1);
+    }
+
+    @Override
+    public boolean add(final long k) {
+        boolean out = backing.add(k);
+		/*
+		if (!firstDef) {
+			first = k;
+			firstDef = true;
+		}
+		last = k;
+		*/
+        return out;
+    }
+
+    @Override
+    public boolean addAll(LongCollection c) {
+        return addAll((Collection<Long>) c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends Long> c) {
+        return backing.addAll(c);
+    }
+
+    @Override
+    public boolean addAndMoveToFirst(final long k) {
+        boolean out = backing.add(k);
+        //first = k;
+        return out;
+    }
+
+    @Override
+    public boolean addAndMoveToLast(final long k) {
+        boolean out = backing.add(k);
+        //last = k;
+        return out;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public LongLinkedOpenHashSet clone() {
+        return new ConcurrentLongLinkedOpenHashSet(backing.iterator());
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+    @Override
+    public boolean contains(final long k) {
+        return backing.contains(k);
+    }
+
+    @Override
+    public long firstLong() {
+		/*
+		if (backing.size() == 0) throw new NoSuchElementException();
+		return first;
+		*/
+        return backing.first();
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public LongSortedSet headSet(long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public LongListIterator iterator() {
+        return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public LongListIterator iterator(long from) {
+        throw new IllegalStateException();
+        //return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public long lastLong() {
+		/*
+		if (backing.size() == 0) throw new NoSuchElementException();
+		return last;
+		*/
+        return backing.last();
+    }
+
+    @Override
+    public boolean remove(final long k) {
+		/*
+		if (k == first) {
+			first = backing.iterator().next();
+		}
+		if (k == last) {
+			last = backing.iterator().next();
+		}
+		*/
+        return backing.remove(k);
+    }
+
+    @Override
+    public long removeFirstLong() {
+        long fl = this.firstLong();
+        this.remove(fl);
+        //first = backing.iterator().next();
+        return fl;
+    }
+
+    @Override
+    public long removeLastLong() {
+        long fl = this.lastLong();
+        this.remove(fl);
+        //last = backing.iterator().next();
+        return fl;
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public LongSortedSet subSet(long from, long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongSortedSet tailSet(long from) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean trim() {
+        return true;
+    }
+
+    @Override
+    public boolean trim(final int n) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..75ed422b3349e3b417ea4b2bbed57f27fda947f5
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java
@@ -0,0 +1,134 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.shorts.ShortCollection;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import it.unimi.dsi.fastutil.shorts.ShortSet;
+
+import java.util.Collection;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ConcurrentShortHashSet implements ShortSet {
+
+    ConcurrentHashMap.KeySetView<Short, Boolean> backing = new ConcurrentHashMap<Short, Integer>().newKeySet();
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return false;
+    }
+
+    @Override
+    public ShortIterator iterator() {
+        return new FastUtilHackUtil.WrappingShortIterator(backing.iterator());
+    }
+
+    @Override
+    public Object[] toArray() {
+        return backing.toArray();
+    }
+
+    @Override
+    public <T> T[] toArray( T[] ts) {
+        return (T[]) backing.toArray();
+    }
+
+    @Override
+    public boolean add(Short aShort) {
+        return false;
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        return false;
+    }
+
+    @Override
+    public boolean containsAll( Collection<?> collection) {
+        return backing.containsAll(collection);
+    }
+
+    @Override
+    public boolean addAll( Collection<? extends Short> collection) {
+        return backing.addAll(collection);
+    }
+
+    @Override
+    public boolean removeAll( Collection<?> collection) {
+        return backing.removeAll(collection);
+    }
+
+    @Override
+    public boolean retainAll( Collection<?> collection) {
+        return backing.retainAll(collection);
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+
+    }
+
+    @Override
+    public boolean add(short key) {
+        return backing.add(key);
+    }
+
+    @Override
+    public boolean rem(short key) {
+        return false;
+    }
+
+    @Override
+    public boolean contains(short key) {
+        return backing.contains(key);
+    }
+
+    @Override
+    public short[] toShortArray() {
+        return new short[0];
+    }
+
+    @Override
+    public short[] toShortArray(short[] a) {
+        return new short[0];
+    }
+
+    @Override
+    public short[] toArray(short[] a) {
+        return new short[0];
+    }
+
+    @Override
+    public boolean addAll(ShortCollection c) {
+        return backing.addAll(c);
+    }
+
+    @Override
+    public boolean containsAll(ShortCollection c) {
+        return backing.containsAll(c);
+    }
+
+    @Override
+    public boolean removeAll(ShortCollection c) {
+        return backing.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(ShortCollection c) {
+        return backing.retainAll(c);
+    }
+
+    @Override
+    public boolean remove(short k) {
+        return backing.remove(k);
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..428983eb191231e82d8821583e476a516394b51b
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java
@@ -0,0 +1,1966 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.ListIterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import it.unimi.dsi.fastutil.longs.*;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import org.apache.commons.lang3.ArrayUtils;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.bytes.ByteIterator;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.ints.IntIterator;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+public class FastUtilHackUtil {
+
+    public static class ConvertingObjectSet<E, T> implements ObjectSet<T> {
+
+        Set<E> backing;
+        Function<E, T> forward;
+        Function<T, E> back;
+
+        public ConvertingObjectSet(Set<E> backing, Function<E, T> forward, Function<T, E> back) {
+            this.backing = backing;
+            this.forward = forward;
+            this.back = back;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+        @Override
+        public boolean add(T e) {
+            return backing.add(back.apply(e));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends T> c) {
+            return backing.addAll(c.stream().map(i -> back.apply(i)).collect(Collectors.toSet()));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+
+        }
+
+        @Override
+        public ObjectIterator<T> iterator() {
+            final Iterator<E> backg = backing.iterator();
+            return new ObjectIterator<T>() {
+
+                @Override
+                public int skip(int n) {
+                    return 0;
+                }
+
+                @Override
+                public boolean hasNext() {
+                    return backg.hasNext();
+                }
+
+                @Override
+                public T next() {
+                    return forward.apply(backg.next());
+                }
+
+                @Override
+                public void remove() {
+                    backg.remove();
+                }
+            };
+        }
+    }
+
+    public static class ConvertingObjectSetFast<E,T> implements it.unimi.dsi.fastutil.longs.Long2ObjectMap.FastEntrySet<T> {
+
+        Set<E> backing;
+        Function<E, it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> forward;
+        Function<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>, E> back;
+
+        public ConvertingObjectSetFast(Set<E> backing,
+                                       Function<E, it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> forward,
+                                       Function<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>, E> back) {
+            this.backing = backing;
+            this.forward = forward;
+            this.back = back;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>)o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>)o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream()
+                        .map(i -> back.apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream().map(i -> back
+                                .apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream()
+                        .map(i -> back.apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+
+        }
+
+        @Override
+        public ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> iterator() {
+            final Iterator<E> backg = backing.iterator();
+            return new ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>>() {
+
+                @Override
+                public int skip(int n) {
+                    return 0;
+                }
+
+                @Override
+                public boolean hasNext() {
+                    return backg.hasNext();
+                }
+
+                @Override
+                public it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T> next() {
+                    return forward.apply(backg.next());
+                }
+
+                @Override
+                public void remove() {
+                    backg.remove();
+                }
+            };
+        }
+
+        @Override
+        public boolean add(it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T> e) {
+            return backing.add(back.apply(e));
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> c) {
+            return backing.addAll(c.stream().map(back).collect(Collectors.toList()));
+        }
+
+        @Override
+        public ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> fastIterator() {
+            return iterator();
+        }
+
+
+    }
+
+    private static <T> Int2ObjectMap.Entry<T> intEntryForwards(Map.Entry<Integer, T> entry) {
+        return new Int2ObjectMap.Entry<T>() {
+
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public Integer getKey() {
+                return null;
+            }
+
+            @Override
+            public int getIntKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Integer, T> intEntryBackwards(Int2ObjectMap.Entry<T> entry) {
+        return entry;
+    }
+
+    private static <T> Long2ObjectMap.Entry<T> longEntryForwards(Map.Entry<Long, T> entry) {
+        return new Long2ObjectMap.Entry<T>() {
+
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public Long getKey() {
+                return null;
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Long, T> longEntryBackwards(Long2ObjectMap.Entry<T> entry) {
+        return entry;
+    }
+
+    private static Long2ByteMap.Entry longByteEntryForwards(Map.Entry<Long, Byte> entry) {
+        return new Long2ByteMap.Entry() {
+
+            @Override
+            public Byte getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public Byte setValue(Byte value) {
+                return null;
+            }
+
+            @Override
+            public byte setValue(byte value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public byte getByteValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public Long getKey() {
+                return null;
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+
+        };
+    }
+
+    private static <T> Map.Entry<Long, Byte> longByteEntryBackwards(Long2ByteMap.Entry entry) {
+        return entry;
+    }
+
+    private static Long2LongMap.Entry longLongEntryForwards(Map.Entry<Long, Long> entry) {
+        return new Long2LongMap.Entry() {
+
+            @Override
+            public Long getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public Long setValue(Long value) {
+                return null;
+            }
+
+            @Override
+            public long setValue(long value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public long getLongValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public Long getKey() {
+                return null;
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+
+        };
+    }
+
+    private static <T> Map.Entry<Long, Long> longLongEntryBackwards(Long2LongMap.Entry entry) {
+        return entry;
+    }
+
+    public static <T> ObjectSet<Int2ObjectMap.Entry<T>> entrySetIntWrap(Map<Integer, T> map) {
+        return new ConvertingObjectSet<Map.Entry<Integer, T>, Int2ObjectMap.Entry<T>>(map.entrySet(), FastUtilHackUtil::intEntryForwards, FastUtilHackUtil::intEntryBackwards);
+    }
+
+    public static <T> ObjectSet<Long2ObjectMap.Entry<T>> entrySetLongWrap(Map<Long, T> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, T>, Long2ObjectMap.Entry<T>>(map.entrySet(), FastUtilHackUtil::longEntryForwards, FastUtilHackUtil::longEntryBackwards);
+    }
+
+    public static <T> it.unimi.dsi.fastutil.longs.Long2ObjectMap.FastEntrySet<T> entrySetLongWrapFast(Map<Long, T> map) {
+        return new ConvertingObjectSetFast<Map.Entry<Long, T>, T>(map.entrySet(), FastUtilHackUtil::longEntryForwards, FastUtilHackUtil::longEntryBackwards);
+    }
+
+    public static ObjectSet<Long2ByteMap.Entry> entrySetLongByteWrap(Map<Long, Byte> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, Byte>, Long2ByteMap.Entry>(map.entrySet(), FastUtilHackUtil::longByteEntryForwards, FastUtilHackUtil::longByteEntryBackwards);
+    }
+
+    public static ObjectSet<Long2LongMap.Entry> entrySetLongLongWrap(Map<Long, Long> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, Long>, Long2LongMap.Entry>(map.entrySet(), FastUtilHackUtil::longLongEntryForwards, FastUtilHackUtil::longLongEntryBackwards);
+    }
+
+
+    static class WrappingIntIterator implements IntIterator {
+
+        Iterator<Integer> backing;
+
+        public WrappingIntIterator(Iterator<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public int nextInt() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public Integer next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    static class WrappingLongIterator implements LongIterator {
+
+        Iterator<Long> backing;
+
+        public WrappingLongIterator(Iterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public Long next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    static class WrappingShortIterator implements ShortIterator {
+
+        Iterator<Short> backing;
+
+        public WrappingShortIterator(Iterator<Short> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public short nextShort() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public Short next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    public static class WrappingIntSet implements IntSet {
+
+        Set<Integer> backing;
+
+        public WrappingIntSet(Set<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(int key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean rem(int key) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(int key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return backing.stream().mapToInt(i -> i).toArray();
+        }
+
+        @Override
+        public int[] toIntArray(int[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toIntArray();
+            }
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return toIntArray(a);
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Integer integer) {
+            return false;
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return new WrappingIntIterator(backing.iterator());
+        }
+
+        @Override
+        public IntIterator intIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean remove(int k) {
+            return backing.remove(k);
+        }
+
+    }
+
+    public static LongSet wrapLongSet(Set<Long> longset) {
+        return new WrappingLongSet(longset);
+    }
+
+    public static class WrappingLongSet implements LongSet {
+
+        Set<Long> backing;
+
+        public WrappingLongSet(Set<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean rem(long key) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(i -> i).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toLongArray();
+            }
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Long aLong) {
+            return false;
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return new WrappingLongIterator(backing.iterator());
+        }
+
+        @Override
+        public LongIterator longIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+
+    }
+
+    public static LongSortedSet wrapLongSortedSet(Set<Long> longset) {
+        return new WrappingLongSortedSet(longset);
+    }
+
+    public static class WrappingLongSortedSet implements LongSortedSet {
+
+        Set<Long> backing;
+
+        public WrappingLongSortedSet(Set<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean rem(long key) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(i -> i).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toLongArray();
+            }
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Long aLong) {
+            return false;
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator(long fromElement) {
+            throw new UnsupportedOperationException();
+            //return FastUtilHackUtil.wrap(new LinkedList<Long>(backing).iterator());
+        }
+
+        @Override
+        public LongBidirectionalIterator longIterator() {
+            return null;
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator() {
+            return FastUtilHackUtil.wrap(new LinkedList<Long>(backing).iterator());
+        }
+
+        @Override
+        public LongSortedSet subSet(Long fromElement, Long toElement) {
+            return null;
+        }
+
+        @Override
+        public LongSortedSet headSet(Long toElement) {
+            return null;
+        }
+
+        @Override
+        public LongSortedSet tailSet(Long fromElement) {
+            return null;
+        }
+
+        @Override
+        public Long first() {
+            return null;
+        }
+
+        @Override
+        public Long last() {
+            return null;
+        }
+
+        @Override
+        public LongSortedSet subSet(long fromElement, long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet headSet(long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet tailSet(long fromElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongComparator comparator() {
+            return null;
+        }
+
+        @Override
+        public long firstLong() {
+            return backing.stream().findAny().get();
+        }
+
+        @Override
+        public long lastLong() {
+            return backing.stream().findAny().get();
+        }
+
+    }
+
+    public static IntSet wrapIntSet(Set<Integer> intset) {
+        return new WrappingIntSet(intset);
+    }
+
+    public static class WrappingObjectCollection<V> implements ObjectCollection<V> {
+
+        Collection<V> backing;
+
+        public WrappingObjectCollection(Collection<V> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(V e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends V> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ObjectIterator<V> iterator() {
+            return FastUtilHackUtil.itrWrap(backing);
+        }
+
+    }
+
+    public static <K> ObjectCollection<K> wrap(Collection<K> c) {
+        return new WrappingObjectCollection<K>(c);
+    }
+
+    public static class WrappingByteCollection implements ByteCollection {
+
+        Collection<Byte> backing;
+
+        public WrappingByteCollection(Collection<Byte> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(byte o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Byte aByte) {
+            return false;
+        }
+
+        @Override
+        public boolean add(byte e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Byte> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ByteIterator iterator() {
+            return FastUtilHackUtil.itrByteWrap(backing);
+        }
+        
+        @Override
+        public boolean rem(byte key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public byte[] toByteArray() {
+            return null;
+        }
+
+        @Override
+        public byte[] toByteArray(byte[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public byte[] toArray(byte[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Byte[0]));
+        }
+
+        @Override
+        public boolean addAll(ByteCollection c) {
+            return addAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean containsAll(ByteCollection c) {
+            return containsAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean removeAll(ByteCollection c) {
+            return removeAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean retainAll(ByteCollection c) {
+            return retainAll((Collection<Byte>) c);
+        }
+
+    }
+
+    public static ByteCollection wrapBytes(Collection<Byte> c) {
+        return new WrappingByteCollection(c);
+    }
+
+    public static class WrappingIntCollection implements IntCollection {
+
+        Collection<Integer> backing;
+
+        public WrappingIntCollection(Collection<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(int o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Integer integer) {
+            return false;
+        }
+
+        @Override
+        public boolean add(int e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return FastUtilHackUtil.itrIntWrap(backing);
+        }
+
+        @Override
+        public IntIterator intIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean rem(int key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return null;
+        }
+
+        @Override
+        public int[] toIntArray(int[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Integer[0]));
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return addAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return containsAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return removeAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return retainAll((Collection<Integer>) c);
+        }
+
+    }
+
+    public static IntCollection wrapInts(Collection<Integer> c) {
+        return new WrappingIntCollection(c);
+    }
+
+    public static class WrappingLongCollection implements LongCollection {
+
+        Collection<Long> backing;
+
+        public WrappingLongCollection(Collection<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(long o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Long aLong) {
+            return false;
+        }
+
+        @Override
+        public boolean add(long e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return FastUtilHackUtil.itrLongWrap(backing);
+        }
+
+        @Override
+        public LongIterator longIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean rem(long key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return null;
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Long[0]));
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return addAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return containsAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return removeAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return retainAll((Collection<Long>) c);
+        }
+
+    }
+
+    public static LongCollection wrapLongs(Collection<Long> c) {
+        return new WrappingLongCollection(c);
+    }
+
+
+    public static class WrappingLongListIterator implements LongListIterator {
+
+        ListIterator<Long> backing;
+
+        public WrappingLongListIterator(ListIterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public long previousLong() {
+            return backing.previous();
+        }
+
+        @Override
+        public int back(int n) {
+            return 0;
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public Long next() {
+            return null;
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            return backing.hasPrevious();
+        }
+
+        @Override
+        public Long previous() {
+            return null;
+        }
+
+        @Override
+        public int nextIndex() {
+            return backing.nextIndex();
+        }
+
+        @Override
+        public int previousIndex() {
+            return backing.previousIndex();
+        }
+
+        @Override
+        public void add(long k) {
+            backing.add(k);
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(Long aLong) {
+
+        }
+
+        @Override
+        public void add(Long aLong) {
+
+        }
+
+        @Override
+        public void set(long k) {
+            backing.set(k);
+        }
+    }
+
+    public static class SlimWrappingLongListIterator implements LongListIterator {
+
+        Iterator<Long> backing;
+
+        public SlimWrappingLongListIterator(Iterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public long previousLong() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public int back(int n) {
+            return 0;
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public Long next() {
+            return null;
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public Long previous() {
+            return null;
+        }
+
+        @Override
+        public int nextIndex() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public int previousIndex() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public void add(long k) {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(Long aLong) {
+
+        }
+
+        @Override
+        public void add(Long aLong) {
+
+        }
+
+        @Override
+        public void set(long k) {
+            throw new IllegalStateException();
+        }
+    }
+
+    public static LongListIterator wrap(ListIterator<Long> c) {
+        return new WrappingLongListIterator(c);
+    }
+
+    public static LongListIterator wrap(Iterator<Long> c) {
+        return new SlimWrappingLongListIterator(c);
+    }
+
+    public static class WrappingByteIterator implements ByteIterator {
+
+        Iterator<Byte> parent;
+
+        public WrappingByteIterator(Iterator<Byte> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public Byte next() {
+            return parent.next();
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+        @Override
+        public byte nextByte() {
+            return next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+    }
+
+    public static ByteIterator itrByteWrap(Iterator<Byte> backing) {
+        return new WrappingByteIterator(backing);
+    }
+
+    public static ByteIterator itrByteWrap(Iterable<Byte> backing) {
+        return new WrappingByteIterator(backing.iterator());
+    }
+
+    public static IntIterator itrIntWrap(Iterator<Integer> backing) {
+        return new WrappingIntIterator(backing);
+    }
+
+    public static IntIterator itrIntWrap(Iterable<Integer> backing) {
+        return new WrappingIntIterator(backing.iterator());
+    }
+
+    public static LongIterator itrLongWrap(Iterator<Long> backing) {
+        return new WrappingLongIterator(backing);
+    }
+
+    public static LongIterator itrLongWrap(Iterable<Long> backing) {
+        return new WrappingLongIterator(backing.iterator());
+    }
+
+    public static ShortIterator itrShortWrap(Iterator<Short> backing) {
+        return new WrappingShortIterator(backing);
+    }
+
+    public static ShortIterator itrShortWrap(Iterable<Short> backing) {
+        return new WrappingShortIterator(backing.iterator());
+    }
+
+    public static class WrapperObjectIterator<T> implements ObjectIterator<T> {
+
+        Iterator<T> parent;
+
+        public WrapperObjectIterator(Iterator<T> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public T next() {
+            return parent.next();
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+    }
+
+    public static class IntWrapperEntry<T> implements Entry<T> {
+
+        java.util.Map.Entry<Integer, T> parent;
+
+        public IntWrapperEntry(java.util.Map.Entry<Integer, T> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public T getValue() {
+            return parent.getValue();
+        }
+
+        @Override
+        public T setValue(T value) {
+            return parent.setValue(value);
+        }
+
+        @Override
+        public int getIntKey() {
+            return parent.getKey();
+        }
+
+        @Override
+        public Integer getKey() {
+            return parent.getKey();
+        }
+
+    }
+
+    public static class Long2IntWrapperEntry implements Long2IntMap.Entry {
+
+        java.util.Map.Entry<Long, Integer> parent;
+
+        public Long2IntWrapperEntry(java.util.Map.Entry<Long, Integer> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public Long getKey() {
+            return null;
+        }
+
+        @Override
+        public long getLongKey() {
+            return parent.getKey();
+        }
+
+        @Override
+        public Integer getValue() {
+            return null;
+        }
+
+        @Override
+        public Integer setValue(Integer value) {
+            return null;
+        }
+
+        @Override
+        public int getIntValue() {
+            return parent.getValue();
+        }
+
+        @Override
+        public int setValue(int value) {
+            return parent.setValue(value);
+        }
+
+
+    }
+
+    public static class WrapperIntEntryObjectIterator<T> implements ObjectIterator<Entry<T>> {
+
+        Iterator<Map.Entry<Integer, T>> parent;
+
+        public WrapperIntEntryObjectIterator(Iterator<Map.Entry<Integer, T>> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public Entry<T> next() {
+            Map.Entry<Integer, T> val = parent.next();
+            if (val == null) return null;
+            return new IntWrapperEntry<T>(val);
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+    }
+
+    public static <T> ObjectIterator<Entry<T>> intMapItrFake(Map<Integer, T> in) {
+        return new WrapperIntEntryObjectIterator<T>(in.entrySet().iterator());
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterator<T> in) {
+        return new WrapperObjectIterator<T>(in);
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterable<T> in) {
+        return new WrapperObjectIterator<T>(in.iterator());
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..ae72eacbba75ccedd9d280d2e9b03ab20fb8f3d7
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java
@@ -0,0 +1,114 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+import org.apache.commons.lang3.NotImplementedException;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Int2ObjectConcurrentHashMap<V> implements Int2ObjectMap<V> {
+
+    Map<Integer, V> backing;
+
+
+    public Int2ObjectConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Integer, V>();
+    }
+
+    @Override
+    public V get(int key) {
+        return backing.get(key);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Integer, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        throw new NotImplementedException("MCMT - Not implemented");
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Integer, V>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> int2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetIntWrap(backing);
+    }
+
+
+    @Override
+    public IntSet keySet() {
+        return FastUtilHackUtil.wrapIntSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(int key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(int key, V value) {
+        return backing.put(key, value);
+    }
+
+    @Override
+    public V put(Integer key, V value) {
+        return backing.put(key, value);
+    }
+
+    @Override
+    public V get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public V remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public V remove(int key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public void clear() { backing.clear(); }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f61dc88c6e5d4ab74a169e7da04f312365ca14c
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java
@@ -0,0 +1,125 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.longs.Long2ByteMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2ByteConcurrentHashMap implements Long2ByteMap {
+
+    Map<Long, Byte> backing;
+    byte defaultReturn = 0;
+    byte nullKey = 0;
+
+    public Long2ByteConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, Byte>();
+    }
+
+    @Override
+    public byte get(long key) {
+        Byte out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(byte value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Byte> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void clear() {
+
+    }
+
+    @Override
+    public void defaultReturnValue(byte rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public byte defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, Byte>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2ByteEntrySet() {
+        return FastUtilHackUtil.entrySetLongByteWrap(backing);
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ByteCollection values() {
+        return FastUtilHackUtil.wrapBytes(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public byte put(long key, byte value) {
+        return put((Long)key, (Byte)value);
+    }
+
+    @Override
+    public Byte put(Long key, Byte value) {
+        Byte out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public Byte get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return false;
+    }
+
+    @Override
+    public Byte remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public byte remove(long key) {
+        Byte out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f0f103e822fdb4495e494a650c69bd981436edd
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java
@@ -0,0 +1,119 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2IntConcurrentHashMap implements Long2IntMap {
+
+    public Map<Long, Integer> backing = new ConcurrentHashMap<Long, Integer>();
+    int defaultRV = 0;
+
+    @Override
+    public int put(long key, int value) {
+        return 0;
+    }
+
+    @Override
+    public int get(long key) {
+        if (backing.containsKey(key)) {
+            return backing.get(key);
+        } else return defaultRV;
+    }
+
+    @Override
+    public int remove(long key) {
+        return 0;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Integer> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public Integer put(Long key, Integer value) {
+        return null;
+    }
+
+    @Override
+    public Integer get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return false;
+    }
+
+    @Override
+    public Integer remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void clear() {
+
+    }
+
+    @Override
+    public void defaultReturnValue(int rv) {
+        defaultRV = rv;
+    }
+
+    @Override
+    public int defaultReturnValue() {
+        return defaultRV;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, Integer>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2IntEntrySet() {
+        return null;
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public IntCollection values() {
+        return FastUtilHackUtil.wrapInts(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(int value) {
+        return backing.containsValue(value);
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..1977a40ce543b19387e223dc2b41726f5daaef43
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java
@@ -0,0 +1,373 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.Hash;
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.longs.*;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+@SuppressWarnings("deprecation")
+public class Long2IntConcurrentNonLinkedOpenMap extends Long2IntLinkedOpenHashMap {
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = -2082212127278131631L;
+
+    public Map<Long, Integer> backing = new ConcurrentHashMap<Long, Integer>();
+
+    public Long2IntConcurrentNonLinkedOpenMap(final int expected, final float f) {
+
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
+     *
+     * @param expected the expected number of elements in the hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final int expected) {
+    }
+
+    /**
+     * Creates a new hash map with initial expected
+     * {@link Hash#DEFAULT_INITIAL_SIZE} entries and
+     * {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap() {
+    }
+
+    /**
+     * Creates a new hash map copying a given one.
+     *
+     * @param m a {@link Map} to be copied into the new hash map.
+     * @param f the load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Map<? extends Long, ? extends Integer> m, final float f) {
+        putAll(m);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * copying a given one.
+     *
+     * @param m a {@link Map} to be copied into the new hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Map<? extends Long, ? extends Integer> m) {
+        this(m, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new hash map copying a given type-specific one.
+     *
+     * @param m a type-specific map to be copied into the new hash map.
+     * @param f the load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Long2IntMap m, final float f) {
+        this(m.size(), f);
+        putAll(m);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * copying a given type-specific one.
+     *
+     * @param m a type-specific map to be copied into the new hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Long2IntMap m) {
+        this(m, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new hash map using the elements of two parallel arrays.
+     *
+     * @param k the array of keys of the new hash map.
+     * @param v the array of corresponding values in the new hash map.
+     * @param f the load factor.
+     * @throws IllegalArgumentException if {@code k} and {@code v} have different
+     *                                  lengths.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final long[] k, final int[] v, final float f) {
+        if (k.length != v.length)
+            throw new IllegalArgumentException(
+                    "The key array and the value array have different lengths (" + k.length + " and " + v.length + ")");
+        for (int i = 0; i < k.length; i++)
+            this.put(k[i], v[i]);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * using the elements of two parallel arrays.
+     *
+     * @param k the array of keys of the new hash map.
+     * @param v the array of corresponding values in the new hash map.
+     * @throws IllegalArgumentException if {@code k} and {@code v} have different
+     *                                  lengths.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final long[] k, final int[] v) {
+        this(k, v, DEFAULT_LOAD_FACTOR);
+    }
+
+    public void putAll(Map<? extends Long, ? extends Integer> m) {
+        backing.putAll(m);
+    }
+
+    public int put(final long k, final int v) {
+        Integer out = backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int addTo(final long k, final int incr) {
+        Integer out =  backing.put(k, this.get(k)+incr);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int remove(final long k) {
+        Integer out = backing.remove(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int removeFirstInt() {
+        Integer out = this.remove(backing.keySet().stream().findAny().get());
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int removeLastInt() {
+        Integer out = this.remove(backing.keySet().stream().findAny().get());
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int getAndMoveToFirst(final long k) {
+        Integer out = backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int getAndMoveToLast(final long k) {
+        Integer out = backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putAndMoveToFirst(final long k, final int v) {
+        Integer out =  backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putAndMoveToLast(final long k, final int v) {
+        Integer out =  backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int get(final long k) {
+        Integer out =  backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public boolean containsKey(final long k) {
+        return backing.containsKey(k);
+    }
+
+    public boolean containsValue(final int v) {
+        return backing.containsValue(v);
+    }
+
+    public int getOrDefault(final long k, final int defaultValue) {
+        Integer out =  backing.getOrDefault(k, defaultValue);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putIfAbsent(final long k, final int v) {
+        Integer out =  backing.putIfAbsent(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public boolean remove(final long k, final int v) {
+        return backing.remove(k, v);
+    }
+
+
+    public boolean replace(final long k, final int oldValue, final int v) {
+        return  backing.replace(k, oldValue, v);
+    }
+
+
+    public int replace(final long k, final int v) {
+        Integer out = backing.replace(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfAbsent(final long k, final java.util.function.LongToIntFunction mappingFunction) {
+        Integer out =  backing.computeIfAbsent(k, (l) -> mappingFunction.applyAsInt(l));
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfAbsentNullable(final long k,
+                                       final java.util.function.LongFunction<? extends Integer> mappingFunction) {
+        Integer out =  backing.computeIfAbsent(k, (l) -> mappingFunction.apply(l));
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfPresent(final long k,
+                                final java.util.function.BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        if (this.containsKey(k)) {
+            Integer out =  backing.put(k, remappingFunction.apply(k, backing.get(k)));
+            if (out == null) {
+                return defRetValue;
+            }
+            return out;
+        }
+        return defaultReturnValue();
+
+    }
+
+    public int compute(final long k,
+                       final java.util.function.BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        Integer out = backing.compute(k, remappingFunction);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int merge(final long k, final int v,
+                     final java.util.function.BiFunction<? super Integer, ? super Integer, ? extends Integer> remappingFunction) {
+        Integer out =  backing.merge(k, v, remappingFunction);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public long firstLongKey() {
+        return backing.keySet().stream().findAny().get();
+    }
+
+    @Override
+    public long lastLongKey() {
+        return backing.keySet().stream().findAny().get();
+    }
+
+    @Override
+    public Long2IntSortedMap tailMap(long from) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Long2IntSortedMap headMap(long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Long2IntSortedMap subMap(long from, long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+
+    @Override
+    public FastSortedEntrySet long2IntEntrySet() {
+        //TODO implement
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongSortedSet keySet() {
+        return FastUtilHackUtil.wrapLongSortedSet(backing.keySet());
+    }
+
+
+    @Override
+    public IntCollection values() {
+        return FastUtilHackUtil.wrapInts(backing.values());
+    }
+
+    public boolean trim() {
+        return true;
+    }
+
+    public boolean trim(final int n) {
+        return true;
+    }
+
+
+    @Override
+    public Long2IntConcurrentNonLinkedOpenMap clone() {
+        return new Long2IntConcurrentNonLinkedOpenMap(backing);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3b5d43def8e2d0abdeb202629d43b299cad3232
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java
@@ -0,0 +1,127 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+public class Long2LongConcurrentHashMap implements Long2LongMap {
+
+    public Map<Long, Long> backing = new ConcurrentHashMap<Long, Long>();
+    long defaultRV = 0;
+
+    public Long2LongConcurrentHashMap(long defaultRV) {
+        this.defaultRV = defaultRV;
+    }
+
+    @Override
+    public long get(long key) {
+        if (backing.containsKey(key)) {
+            return backing.get(key);
+        } else return defaultRV;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public long put(final long key, final long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public Long put(final Long key, final Long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public Long get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return false;
+    }
+
+    @Override
+    public Long remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public long remove(final long key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Long> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void clear() {
+
+    }
+
+    @Override
+    public void defaultReturnValue(long rv) {
+        defaultRV = rv;
+    }
+
+    @Override
+    public long defaultReturnValue() {
+        return defaultRV;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, Long>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2LongEntrySet() {
+        return FastUtilHackUtil.entrySetLongLongWrap(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public LongCollection values() {
+        return FastUtilHackUtil.wrapLongs(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(long value) {
+        return backing.containsValue(value);
+    }
+
+
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..16f9677a7ed4e5bf2badab39d0ecf3eeae5a39d1
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java
@@ -0,0 +1,122 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2ObjectConcurrentHashMap<V> implements Long2ObjectMap<V> {
+
+    Map<Long, V> backing;
+    V defaultReturn = null;
+
+    public Long2ObjectConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, V>();
+    }
+
+    public Long2ObjectConcurrentHashMap(int e) {
+        backing = new ConcurrentHashMap<Long, V>(e);
+    }
+
+    @Override
+    public V get(long key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void clear() {
+
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, V>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrap(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        return put((Long)key, value);
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        V out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public V get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public V remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public V remove(long key) {
+        V out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..2f6c6b63c7f0cb27808fd4c49eec6de3413138bd
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java
@@ -0,0 +1,225 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectFunction;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Function;
+
+import static it.unimi.dsi.fastutil.HashCommon.nextPowerOfTwo;
+
+public class Long2ObjectOpenConcurrentHashMap<V> extends Long2ObjectOpenHashMap<V> {
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = -121514116954680057L;
+
+    Map<Long, V> backing;
+    V defaultReturn = null;
+
+    public Long2ObjectOpenConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, V>();
+    }
+
+    public Long2ObjectOpenConcurrentHashMap(int e){
+        final long s = Math.max(2, nextPowerOfTwo( (long)Math.ceil( e / .75f ) ) );
+        backing = new ConcurrentHashMap<>();
+    }
+
+    @Override
+    public V get(long key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public V get(Object key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public FastEntrySet<V> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrapFast(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        return put((Long)key, value);
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        V out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public V remove(long key) {
+        V out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean trim() { return true; }
+
+    @Override
+    public boolean trim(final int n) { return true; }
+
+
+    public boolean replace(final long k, final V oldValue, final V v) {
+        return backing.replace(k, oldValue, v);
+    }
+
+    public V replace(final long k, final V v) {
+        return backing.replace(k, v);
+    }
+
+    @Override
+    public boolean replace(final Long k, final V oldValue, final V v) {
+        return backing.replace(k, oldValue, v);
+    }
+
+    @Override
+    public V replace(final Long k, final V v) {
+        return backing.replace(k, v);
+    }
+
+    public boolean remove(final long k, final Object v) {
+        return backing.remove(k, v);
+    }
+
+    public V putIfAbsent(final long k, final V v) {
+        return backing.putIfAbsent(k, v);
+    }
+
+    @Override
+    public V putIfAbsent(final Long k, final V v) {
+        return backing.putIfAbsent(k, v);
+    }
+
+    public V merge(final long k, final V v, final java.util.function.BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return backing.merge(k, v, remappingFunction);
+    }
+
+    @Override
+    public V merge(Long k, final V v, final java.util.function.BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return backing.merge(k, v, remappingFunction);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    public V getOrDefault(final long k, final V defaultValue) {
+        return backing.getOrDefault(k, defaultValue);
+    }
+
+    @Override
+    public V getOrDefault(Object k, final V defaultValue) {
+        return backing.getOrDefault(k, defaultValue);
+    }
+
+    public V computeIfPresent(final long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.computeIfPresent(k, remappingFunction);
+    }
+
+    @Override
+    public V computeIfPresent(final Long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.computeIfPresent(k, remappingFunction);
+    }
+
+    public V computeIfAbsent(final long k, final java.util.function.LongFunction<? extends V> mappingFunction) {
+        return backing.computeIfAbsent(k, (llong) -> mappingFunction.apply(llong));
+    }
+
+    public V computeIfAbsent(final Long k, final java.util.function.LongFunction<? extends V> mappingFunction) {
+        return backing.computeIfAbsent(k, (llong) -> mappingFunction.apply(llong));
+    }
+
+    public V compute(final long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.compute(k, remappingFunction);
+    }
+
+    @Override
+    public V compute(final Long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.compute(k, remappingFunction);
+    }
+
+    @Override
+    public Long2ObjectOpenHashMap<V> clone() {
+        throw new IllegalArgumentException();
+    }
+
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, V>> entrySet() {
+        return new FastUtilHackUtil.ConvertingObjectSet<java.util.Map.Entry<Long, V>, java.util.Map.Entry<Long, V>>(backing.entrySet(), Function.identity(), Function.identity());
+    }
+
+    @Override
+    public V remove(Object key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public boolean remove(Object key, Object value) {
+        return backing.remove(key, value);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..565dc74cb65ef0ce9df36a72d9cd5fa440a535e6
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java
@@ -0,0 +1,197 @@
+package net.himeki.mcmtfabric.parallelised.fastutil.sync;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+import it.unimi.dsi.fastutil.longs.LongArrays;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import it.unimi.dsi.fastutil.longs.LongComparator;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongIterators;
+import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongListIterator;
+import it.unimi.dsi.fastutil.longs.LongSortedSet;
+
+public class SyncLongLinkedOpenHashSet extends LongLinkedOpenHashSet {
+
+    private static final long serialVersionUID = -5532128240738069111L;
+
+    public SyncLongLinkedOpenHashSet() {
+        super();
+    }
+
+    public SyncLongLinkedOpenHashSet(final int initial) {
+        super(initial);
+    }
+
+    public SyncLongLinkedOpenHashSet(final int initial, final float dnc) {
+        this(initial);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongCollection c) {
+        this(c.size());
+        addAll(c);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongCollection c, final float f) {
+        this(c.size(), f);
+        addAll(c);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongIterator i, final float f) {
+        this(16, f);
+        while (i.hasNext())
+            add(i.nextLong());
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongIterator i) {
+        this(i, -1);
+    }
+
+    public SyncLongLinkedOpenHashSet(final Iterator<?> i, final float f) {
+        this(LongIterators.asLongIterator(i), f);
+    }
+
+    public SyncLongLinkedOpenHashSet(final Iterator<?> i) {
+        this(LongIterators.asLongIterator(i));
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final int offset, final int length, final float f) {
+        this(length < 0 ? 0 : length, f);
+        LongArrays.ensureOffsetLength(a, offset, length);
+        for (int i = 0; i < length; i++)
+            add(a[offset + i]);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final int offset, final int length) {
+        this(a, offset, length, DEFAULT_LOAD_FACTOR);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final float f) {
+        this(a, 0, a.length, f);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a) {
+        this(a, -1);
+    }
+
+    @Override
+    public synchronized boolean add(final long k) {
+        return super.add(k);
+    }
+
+    @Override
+    public synchronized boolean addAll(LongCollection c) {
+        return super.addAll(c);
+    }
+
+    @Override
+    public synchronized boolean addAll(Collection<? extends Long> c) {
+        return super.addAll(c);
+    }
+
+    @Override
+    public synchronized boolean addAndMoveToFirst(final long k) {
+        return super.addAndMoveToFirst(k);
+    }
+
+    @Override
+    public synchronized boolean addAndMoveToLast(final long k) {
+        return super.addAndMoveToFirst(k);
+    }
+
+    @Override
+    public synchronized void clear() {
+        super.clear();
+    }
+
+    @Override
+    public synchronized LongLinkedOpenHashSet clone() {
+        return new SyncLongLinkedOpenHashSet(this);
+    }
+
+    @Override
+    public synchronized LongComparator comparator() {
+        return super.comparator();
+    }
+
+    @Override
+    public synchronized boolean contains(final long k) {
+        return super.contains(k);
+    }
+
+    @Override
+    public synchronized long firstLong() {
+        return super.firstLong();
+    }
+
+    @Override
+    public synchronized int hashCode() {
+        return super.hashCode();
+    }
+
+    @Override
+    public synchronized LongSortedSet headSet(long to) {
+        return super.headSet(to);
+    }
+
+    @Override
+    public synchronized boolean isEmpty() {
+        return super.isEmpty();
+    }
+
+    @Override
+    public synchronized LongListIterator iterator() {
+        return super.iterator();
+    }
+
+    @Override
+    public synchronized LongListIterator iterator(long from) {
+        return super.iterator(from);
+    }
+
+    @Override
+    public synchronized long lastLong() {
+        return super.lastLong();
+    }
+
+    @Override
+    public synchronized boolean remove(final long k) {
+        return super.remove(k);
+    }
+
+    @Override
+    public synchronized long removeFirstLong() {
+        return super.removeFirstLong();
+    }
+
+    @Override
+    public synchronized long removeLastLong() {
+        return super.removeLastLong();
+    }
+
+    @Override
+    public synchronized int size() {
+        return super.size();
+    }
+
+    @Override
+    public synchronized LongSortedSet subSet(long from, long to) {
+        return super.subSet(from, to);
+    }
+
+    @Override
+    public synchronized LongSortedSet tailSet(long from) {
+        return super.tailSet(from);
+    }
+
+    @Override
+    public synchronized boolean trim() {
+        return super.trim();
+    }
+
+    @Override
+    public synchronized boolean trim(final int n) {
+        return super.trim(n);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TickTask.java b/src/main/java/net/minecraft/server/TickTask.java
index 29be8fbc7cd5f1d8068014dde7ac5e4feb0362d0..5ebabc13541228e32d2376d8aa7e4f8b0c557359 100644
--- a/src/main/java/net/minecraft/server/TickTask.java
+++ b/src/main/java/net/minecraft/server/TickTask.java
@@ -15,6 +15,10 @@ public class TickTask implements Runnable {
 
     @Override
     public void run() {
-        this.runnable.run();
+        try{
+            this.runnable.run();
+        }catch (Exception e){
+            e.printStackTrace();
+        }
     }
 }
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 52cba8f68d274cce106304aef1249a95474d3238..282209b8ef083d305d46b8a760ce6d5349ec853f 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -30,6 +30,8 @@ import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
+
+import net.himeki.mcmtfabric.parallelised.fastutil.Long2ObjectConcurrentHashMap;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.thread.ProcessorHandle;
@@ -52,7 +54,7 @@ public abstract class DistanceManager {
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
     private static final int ENTITY_TICKING_LEVEL_THRESHOLD = 32;
     private static final int BLOCK_TICKING_LEVEL_THRESHOLD = 33;
-    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
+    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectConcurrentHashMap<>();
     // Paper - rewrite chunk system
     public static final int MOB_SPAWN_RANGE = 8; // private final DistanceManager.FixedPlayerDistanceChunkTracker naturalSpawnChunkCounter = new DistanceManager.FixedPlayerDistanceChunkTracker(8); // Paper - no longer used
     //private final TickingTracker tickingTicketsTracker = new TickingTracker(); // Paper - no longer used
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 0b75caca3f77980505d0689601d920fb50f7ac4d..8d7ac778adc2b98ed31247ae67a200c601b11e8a 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -2,16 +2,12 @@ package net.minecraft.server.level;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
@@ -296,7 +292,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> tickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
-    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
+    public final Set<LevelChunk> entityTickingChunks = Sets.newConcurrentHashSet();
     // Paper end
 
     public ServerChunkCache(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor workerExecutor, ChunkGenerator chunkGenerator, int viewDistance, int simulationDistance, boolean dsync, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory) {
@@ -750,7 +746,7 @@ public class ServerChunkCache extends ChunkSource {
             if (this.level.paperConfig().entities.spawning.perPlayerMobSpawns) {
                 iterator1 = this.entityTickingChunks.iterator();
             } else {
-                iterator1 = this.entityTickingChunks.unsafeIterator();
+                iterator1 = this.entityTickingChunks.iterator();
                 List<LevelChunk> shuffled = Lists.newArrayListWithCapacity(this.entityTickingChunks.size());
                 while (iterator1.hasNext()) {
                     shuffled.add(iterator1.next());
@@ -847,12 +843,10 @@ public class ServerChunkCache extends ChunkSource {
             if (chunkMap.playerMobDistanceMap != null && _pufferfish_spawnCountsReady.getAndSet(false)) {
                 net.minecraft.server.MinecraftServer.getServer().mobSpawnExecutor.submit(() -> {
                     int mapped = distanceManager.getNaturalSpawnChunkCount();
-                    io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> objectiterator =
-                            level.entityTickList.entities.iterator(io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS);
+                    Iterator<Entity> objectiterator = level.entityTickList.entities.iterator();
                     gg.pufferfish.pufferfish.util.IterableWrapper<Entity> wrappedIterator =
                             new gg.pufferfish.pufferfish.util.IterableWrapper<>(objectiterator);
                     lastSpawnState = NaturalSpawner.createState(mapped, wrappedIterator, this::getFullChunk, null, true);
-                    objectiterator.finishedIterating();
                     _pufferfish_spawnCountsReady.set(true);
                 });
             }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index 4816b5bd54ae6e080af4c19df43d57e852e76146..651ca7bc747f6b0d40adc9a9ad7840c9fe476f80 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -25,6 +25,8 @@ import org.slf4j.Logger;
 
 // CraftBukkit start
 import java.util.ArrayList;
+import java.util.concurrent.CopyOnWriteArrayList;
+
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -409,7 +411,7 @@ public class ServerPlayerGameMode {
             } else {
                 // CraftBukkit start
                 org.bukkit.block.BlockState state = bblock.getState();
-                level.captureDrops = new ArrayList<>();
+                level.captureDrops = new CopyOnWriteArrayList<>();
                 // CraftBukkit end
                 block.playerWillDestroy(this.level, pos, iblockdata, this.player);
                 boolean flag = this.level.removeBlock(pos, false);
diff --git a/src/main/java/net/minecraft/server/level/TickingTracker.java b/src/main/java/net/minecraft/server/level/TickingTracker.java
index 3a75cef0660dacf0e6993b61e4e6f1dc2d9dbde6..f69ea5022654f43fbcefbee972b2a9e3369bc361 100644
--- a/src/main/java/net/minecraft/server/level/TickingTracker.java
+++ b/src/main/java/net/minecraft/server/level/TickingTracker.java
@@ -10,10 +10,16 @@ import java.util.List;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.world.level.ChunkPos;
 
+import net.himeki.mcmtfabric.parallelised.fastutil.Long2ByteConcurrentHashMap;
+import net.himeki.mcmtfabric.parallelised.fastutil.Long2ObjectOpenConcurrentHashMap;
+import net.minecraft.util.SortedArraySet;
+import net.minecraft.world.level.ChunkPos;
+
+// TODO Check the errors !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 public class TickingTracker extends ChunkTracker {
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
-    protected final Long2ByteMap chunks = new Long2ByteOpenHashMap();
-    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap<>();
+    protected final Long2ByteMap chunks = new Long2ByteConcurrentHashMap();
+    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenConcurrentHashMap<>();
 
     public TickingTracker() {
         super(34, 16, 256);
@@ -51,11 +57,11 @@ public class TickingTracker extends ChunkTracker {
     }
 
     public <T> void addTicket(TicketType<T> type, ChunkPos pos, int level, T argument) {
-        this.addTicket(pos.toLong(), new Ticket<>(type, level, argument));
+        this.addTicket(pos.toLong(), new Ticket<>(type, level, argument,type.timeout));
     }
 
     public <T> void removeTicket(TicketType<T> type, ChunkPos pos, int level, T argument) {
-        Ticket<T> ticket = new Ticket<>(type, level, argument);
+        Ticket<T> ticket = new Ticket<>(type, level, argument,type.timeout);
         this.removeTicket(pos.toLong(), ticket);
     }
 
@@ -65,7 +71,8 @@ public class TickingTracker extends ChunkTracker {
         for(Long2ObjectMap.Entry<SortedArraySet<Ticket<?>>> entry : this.tickets.long2ObjectEntrySet()) {
             for(Ticket<?> ticket : entry.getValue()) {
                 if (ticket.getType() == TicketType.PLAYER) {
-                    list.add(Pair.of(ticket, entry.getLongKey()));
+                    Ticket<ChunkPos> t1 = ((Ticket<ChunkPos>) ticket);
+                    list.add(Pair.of(t1, entry.getLongKey()));
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
index 6f181fc878a96b09f126ea8d3b19ce3ee4588e19..bec0fd7226d3aba3a5d03dc04ad24bbfaeff1ddb 100644
--- a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
+++ b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
@@ -11,12 +11,12 @@ import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collectors;
+import java.util.concurrent.ConcurrentHashMap;
 
 public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
-    private final Map<Class<?>, List<T>> byClass = new Reference2ReferenceOpenHashMap<>(); // JettPack
+    private final Map<Class<?>, List<T>> byClass = new ConcurrentHashMap<>();
     private final Class<T> baseClass;
-    private final List<T> allInstances = Lists.newArrayList();
+    private final List<T> allInstances = Lists.newCopyOnWriteArrayList();
 
     public ClassInstanceMultiMap(Class<T> elementType) {
         this.baseClass = elementType;
diff --git a/src/main/java/net/minecraft/util/ThreadingDetector.java b/src/main/java/net/minecraft/util/ThreadingDetector.java
index b6e98aaebe57453b8eceaa633a989aa24409830f..60162cccf765800c6172d1544f2cd9bcf30cbd97 100644
--- a/src/main/java/net/minecraft/util/ThreadingDetector.java
+++ b/src/main/java/net/minecraft/util/ThreadingDetector.java
@@ -17,7 +17,7 @@ import org.slf4j.Logger;
 public class ThreadingDetector {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final String name;
-    private final Semaphore lock = new Semaphore(1);
+    private final Semaphore lock = new Semaphore(255);
     private final Lock stackTraceLock = new ReentrantLock();
     @Nullable
     private volatile Thread threadThatFailedToAcquire;
diff --git a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
index ba96589aab8be0a90144f73f7779769146c7a37e..fbcab0faa855a5ff524c8623cd43e25970b53f15 100644
--- a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
+++ b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
@@ -17,7 +17,7 @@ import net.minecraft.world.level.block.state.BlockState;
 public class CombatTracker {
     public static final int RESET_DAMAGE_STATUS_TIME = 100;
     public static final int RESET_COMBAT_STATUS_TIME = 300;
-    private final List<CombatEntry> entries = Lists.newArrayList();
+    private final List<CombatEntry> entries = Lists.newCopyOnWriteArrayList();
     private final LivingEntity mob;
     private int lastDamageTime;
     private int combatStartTime;
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index c03ebb7709df712837720f4aae5771a65fa45ff3..7ef4e32931c445955230ec6350e114571185e936 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -20,6 +20,7 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.BiConsumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
@@ -109,6 +110,7 @@ import net.minecraft.world.level.entity.EntityInLevelCallback;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.levelgen.ThreadSafeLegacyRandomSource;
 import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.PushReaction;
@@ -163,77 +165,21 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         return tag.contains("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
     }
 
-    // Paper start
-    public static RandomSource SHARED_RANDOM = new RandomRandomSource();
-    private static final class RandomRandomSource extends java.util.Random implements net.minecraft.world.level.levelgen.BitRandomSource {
-        private boolean locked = false;
-
-        @Override
-        public synchronized void setSeed(long seed) {
-            if (locked) {
-                LOGGER.error("Ignoring setSeed on Entity.SHARED_RANDOM", new Throwable());
-            } else {
-                super.setSeed(seed);
-                locked = true;
-            }
-        }
-
-        @Override
-        public RandomSource fork() {
-            return new net.minecraft.world.level.levelgen.LegacyRandomSource(this.nextLong());
-        }
-
-        @Override
-        public net.minecraft.world.level.levelgen.PositionalRandomFactory forkPositional() {
-            return new net.minecraft.world.level.levelgen.LegacyRandomSource.LegacyPositionalRandomFactory(this.nextLong());
-        }
-
-        // these below are added to fix reobf issues that I don't wanna deal with right now
-        @Override
-        public int next(int bits) {
-            return super.next(bits);
-        }
-
-        @Override
-        public int nextInt(int origin, int bound) {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextInt(origin, bound);
-        }
-
-        @Override
-        public long nextLong() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextLong();
-        }
-
-        @Override
-        public int nextInt() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextInt();
-        }
-
-        @Override
-        public int nextInt(int bound) {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextInt(bound);
-        }
-
-        @Override
-        public boolean nextBoolean() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextBoolean();
-        }
+    private static final AtomicLong seedUniquifier = new AtomicLong(8682522807148012L);
+    private static long seedUniquifier() {
+        long current;
+        long next;
+        do {
+            current = seedUniquifier.get();
+            next = current * 1181783497276652981L;
+        } while(!seedUniquifier.compareAndSet(current, next));
 
-        @Override
-        public float nextFloat() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextFloat();
-        }
+        return next;
+    }
 
-        @Override
-        public double nextDouble() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextDouble();
-        }
+    // Paper start
+    public static RandomSource SHARED_RANDOM = new ThreadSafeLegacyRandomSource(seedUniquifier());
 
-        @Override
-        public double nextGaussian() {
-            return super.nextGaussian();
-        }
-    }
     // Paper end
     public org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason; // Paper
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 8849ae489ebdafef6836425729d7714d7e136986..b97ff263599f2c15dc1d7e06433c53a438006e39 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -62,27 +62,27 @@ public class PoiManager extends SectionStorage<PoiSection> {
         this.world = (net.minecraft.server.level.ServerLevel)world; // Paper - rewrite chunk system
     }
 
-    public void add(BlockPos pos, Holder<PoiType> type) {
+    public synchronized void add(BlockPos pos, Holder<PoiType> type) {
         this.getOrCreate(SectionPos.asLong(pos)).add(pos, type);
     }
 
-    public void remove(BlockPos pos) {
+    public synchronized void remove(BlockPos pos) {
         this.getOrLoad(SectionPos.asLong(pos)).ifPresent((poiSet) -> {
             poiSet.remove(pos);
         });
     }
 
-    public long getCountInRange(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized long getCountInRange(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         return this.getInRange(typePredicate, pos, radius, occupationStatus).count();
     }
 
-    public boolean existsAtPosition(ResourceKey<PoiType> type, BlockPos pos) {
+    public synchronized boolean existsAtPosition(ResourceKey<PoiType> type, BlockPos pos) {
         return this.exists(pos, (entry) -> {
             return entry.is(type);
         });
     }
 
-    public Stream<PoiRecord> getInSquare(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized Stream<PoiRecord> getInSquare(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         int i = Math.floorDiv(radius, 16) + 1;
         return ChunkPos.rangeClosed(new ChunkPos(pos), i).flatMap((chunkPos) -> {
             return this.getInChunk(typePredicate, chunkPos, occupationStatus);
@@ -92,7 +92,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         });
     }
 
-    public Stream<PoiRecord> getInRange(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized Stream<PoiRecord> getInRange(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         int i = radius * radius;
         return this.getInSquare(typePredicate, pos, radius, occupationStatus).filter((poi) -> {
             return poi.getPos().distSqr(pos) <= (double)i;
@@ -100,7 +100,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     }
 
     @VisibleForDebug
-    public Stream<PoiRecord> getInChunk(Predicate<Holder<PoiType>> typePredicate, ChunkPos chunkPos, PoiManager.Occupancy occupationStatus) {
+    public synchronized Stream<PoiRecord> getInChunk(Predicate<Holder<PoiType>> typePredicate, ChunkPos chunkPos, PoiManager.Occupancy occupationStatus) {
         return IntStream.range(this.levelHeightAccessor.getMinSection(), this.levelHeightAccessor.getMaxSection()).boxed().map((integer) -> {
             return this.getOrLoad(SectionPos.of(chunkPos, integer).asLong());
         }).filter(Optional::isPresent).flatMap((optional) -> {
@@ -108,11 +108,11 @@ public class PoiManager extends SectionStorage<PoiSection> {
         });
     }
 
-    public Stream<BlockPos> findAll(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized Stream<BlockPos> findAll(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         return this.getInRange(typePredicate, pos, radius, occupationStatus).map(PoiRecord::getPos).filter(posPredicate);
     }
 
-    public Stream<Pair<Holder<PoiType>, BlockPos>> findAllWithType(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized Stream<Pair<Holder<PoiType>, BlockPos>> findAllWithType(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         return this.getInRange(typePredicate, pos, radius, occupationStatus).filter((poi) -> {
             return posPredicate.test(poi.getPos());
         }).map((poi) -> {
@@ -120,27 +120,27 @@ public class PoiManager extends SectionStorage<PoiSection> {
         });
     }
 
-    public Stream<Pair<Holder<PoiType>, BlockPos>> findAllClosestFirstWithType(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized Stream<Pair<Holder<PoiType>, BlockPos>> findAllClosestFirstWithType(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         return this.findAllWithType(typePredicate, posPredicate, pos, radius, occupationStatus).sorted(Comparator.comparingDouble((pair) -> {
             return pair.getSecond().distSqr(pos);
         }));
     }
 
-    public Optional<BlockPos> find(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized Optional<BlockPos> find(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         // Paper start - re-route to faster logic
         BlockPos ret = io.papermc.paper.util.PoiAccess.findAnyPoiPosition(this, typePredicate, posPredicate, pos, radius, occupationStatus, false);
         return Optional.ofNullable(ret);
         // Paper end
     }
 
-    public Optional<BlockPos> findClosest(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized Optional<BlockPos> findClosest(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         // Paper start - re-route to faster logic
         BlockPos ret = io.papermc.paper.util.PoiAccess.findClosestPoiDataPosition(this, typePredicate, null, pos, radius, radius * radius, occupationStatus, false);
         return Optional.ofNullable(ret);
         // Paper end - re-route to faster logic
     }
 
-    public Optional<Pair<Holder<PoiType>, BlockPos>> findClosestWithType(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized Optional<Pair<Holder<PoiType>, BlockPos>> findClosestWithType(Predicate<Holder<PoiType>> typePredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         // Paper start - re-route to faster logic
         return Optional.ofNullable(io.papermc.paper.util.PoiAccess.findClosestPoiDataTypeAndPosition(
             this, typePredicate, null, pos, radius, radius * radius, occupationStatus, false
@@ -148,14 +148,14 @@ public class PoiManager extends SectionStorage<PoiSection> {
         // Paper end - re-route to faster logic
     }
 
-    public Optional<BlockPos> findClosest(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
+    public synchronized Optional<BlockPos> findClosest(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int radius, PoiManager.Occupancy occupationStatus) {
         // Paper start - re-route to faster logic
         BlockPos ret = io.papermc.paper.util.PoiAccess.findClosestPoiDataPosition(this, typePredicate, posPredicate, pos, radius, radius * radius, occupationStatus, false);
         return Optional.ofNullable(ret);
         // Paper end - re-route to faster logic
     }
 
-    public Optional<BlockPos> take(Predicate<Holder<PoiType>> typePredicate, BiPredicate<Holder<PoiType>, BlockPos> biPredicate, BlockPos pos, int radius) {
+    public synchronized Optional<BlockPos> take(Predicate<Holder<PoiType>> typePredicate, BiPredicate<Holder<PoiType>, BlockPos> biPredicate, BlockPos pos, int radius) {
         // Paper start - re-route to faster logic
         final @javax.annotation.Nullable PoiRecord closest = io.papermc.paper.util.PoiAccess.findClosestPoiDataRecord(
             this, typePredicate, biPredicate, pos, radius, radius * radius, Occupancy.HAS_SPACE, false
@@ -167,7 +167,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         });
     }
 
-    public Optional<BlockPos> getRandom(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> positionPredicate, PoiManager.Occupancy occupationStatus, BlockPos pos, int radius, RandomSource random) {
+    public synchronized Optional<BlockPos> getRandom(Predicate<Holder<PoiType>> typePredicate, Predicate<BlockPos> positionPredicate, PoiManager.Occupancy occupationStatus, BlockPos pos, int radius, RandomSource random) {
         // Paper start - re-route to faster logic
         List<PoiRecord> list = new java.util.ArrayList<>();
         io.papermc.paper.util.PoiAccess.findAnyPoiRecords(
@@ -185,7 +185,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         // Paper end - re-route to faster logic
     }
 
-    public boolean release(BlockPos pos) {
+    public synchronized boolean release(BlockPos pos) {
         return this.getOrLoad(SectionPos.asLong(pos)).map((poiSet) -> {
             return poiSet.release(pos);
         }).orElseThrow(() -> {
@@ -193,13 +193,13 @@ public class PoiManager extends SectionStorage<PoiSection> {
         });
     }
 
-    public boolean exists(BlockPos pos, Predicate<Holder<PoiType>> predicate) {
+    public synchronized boolean exists(BlockPos pos, Predicate<Holder<PoiType>> predicate) {
         return this.getOrLoad(SectionPos.asLong(pos)).map((poiSet) -> {
             return poiSet.exists(pos, predicate);
         }).orElse(false);
     }
 
-    public Optional<Holder<PoiType>> getType(BlockPos pos) {
+    public synchronized Optional<Holder<PoiType>> getType(BlockPos pos) {
         return this.getOrLoad(SectionPos.asLong(pos)).flatMap((poiSet) -> {
             return poiSet.getType(pos);
         });
@@ -208,13 +208,13 @@ public class PoiManager extends SectionStorage<PoiSection> {
     /** @deprecated */
     @Deprecated
     @VisibleForDebug
-    public int getFreeTickets(BlockPos pos) {
+    public synchronized int getFreeTickets(BlockPos pos) {
         return this.getOrLoad(SectionPos.asLong(pos)).map((poiSet) -> {
             return poiSet.getFreeTickets(pos);
         }).orElse(0);
     }
 
-    public int sectionsToVillage(SectionPos pos) {
+    public synchronized int sectionsToVillage(SectionPos pos) {
         this.villageDistanceTracker.propagateUpdates(); // Paper - replace distance tracking util
         return convertBetweenLevels(this.villageDistanceTracker.getLevel(io.papermc.paper.util.CoordinateUtils.getChunkSectionKey(pos))); // Paper - replace distance tracking util
     }
@@ -229,12 +229,12 @@ public class PoiManager extends SectionStorage<PoiSection> {
     }
 
     @Override
-    public void tick(BooleanSupplier shouldKeepTicking) {
+    public synchronized void tick(BooleanSupplier shouldKeepTicking) {
         this.villageDistanceTracker.propagateUpdates(); // Paper - rewrite chunk system
     }
 
     @Override
-    public void setDirty(long pos) {
+    public synchronized void setDirty(long pos) {
         // Paper start - rewrite chunk system
         int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
         int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
@@ -253,7 +253,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     }
 
     @Override
-    public Optional<PoiSection> get(long pos) {
+    public synchronized Optional<PoiSection> get(long pos) {
         int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
         int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
         int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
@@ -267,7 +267,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     }
 
     @Override
-    public Optional<PoiSection> getOrLoad(long pos) {
+    public synchronized Optional<PoiSection> getOrLoad(long pos) {
         int chunkX = io.papermc.paper.util.CoordinateUtils.getChunkSectionX(pos);
         int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
         int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
@@ -307,7 +307,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         }
     }
 
-    public void onUnload(long coordinate) { // Paper - rewrite chunk system
+    public synchronized void onUnload(long coordinate) { // Paper - rewrite chunk system
         int chunkX = io.papermc.paper.util.MCUtil.getCoordinateX(coordinate);
         int chunkZ = io.papermc.paper.util.MCUtil.getCoordinateZ(coordinate);
         io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Unloading poi chunk off-main");
@@ -317,7 +317,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         }
     }
 
-    public void loadInPoiChunk(io.papermc.paper.chunk.system.poi.PoiChunk poiChunk) {
+    public synchronized void loadInPoiChunk(io.papermc.paper.chunk.system.poi.PoiChunk poiChunk) {
         int chunkX = poiChunk.chunkX;
         int chunkZ = poiChunk.chunkZ;
         io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Loading poi chunk off-main");
@@ -330,7 +330,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     }
     // Paper end - rewrite chunk system
 
-    public void checkConsistencyWithBlocks(ChunkPos chunkPos, LevelChunkSection chunkSection) {
+    public synchronized void checkConsistencyWithBlocks(ChunkPos chunkPos, LevelChunkSection chunkSection) {
         SectionPos sectionPos = SectionPos.of(chunkPos, SectionPos.blockToSectionCoord(chunkSection.bottomBlockY()));
         Util.ifElse(this.getOrLoad(sectionPos.asLong()), (poiSet) -> {
             poiSet.refresh((biConsumer) -> {
@@ -361,7 +361,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         });
     }
 
-    public void ensureLoadedAndValid(LevelReader world, BlockPos pos, int radius) {
+    public synchronized void ensureLoadedAndValid(LevelReader world, BlockPos pos, int radius) {
         SectionPos.aroundChunk(new ChunkPos(pos), Math.floorDiv(radius, 16), this.levelHeightAccessor.getMinSection(), this.levelHeightAccessor.getMaxSection()).map((sectionPos) -> {
             return Pair.of(sectionPos, this.getOrLoad(sectionPos.asLong()));
         }).filter((pair) -> {
@@ -403,7 +403,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
 
         }
 
-        public void runAllUpdates() {
+        public synchronized void runAllUpdates() {
             super.runUpdates(Integer.MAX_VALUE);
         }
     }
@@ -411,7 +411,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     // Paper start - Asynchronous chunk io
     @javax.annotation.Nullable
     @Override
-    public net.minecraft.nbt.CompoundTag read(ChunkPos chunkcoordintpair) throws java.io.IOException {
+    public synchronized net.minecraft.nbt.CompoundTag read(ChunkPos chunkcoordintpair) throws java.io.IOException {
         // Paper start - rewrite chunk system
         if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
             return io.papermc.paper.chunk.system.io.RegionFileIOThread.loadData(
@@ -424,7 +424,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     }
 
     @Override
-    public void write(ChunkPos chunkcoordintpair, net.minecraft.nbt.CompoundTag nbttagcompound) throws java.io.IOException {
+    public synchronized void write(ChunkPos chunkcoordintpair, net.minecraft.nbt.CompoundTag nbttagcompound) throws java.io.IOException {
         // Paper start - rewrite chunk system
         if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
             io.papermc.paper.chunk.system.io.RegionFileIOThread.scheduleSave(
diff --git a/src/main/java/net/minecraft/world/level/Explosion.java b/src/main/java/net/minecraft/world/level/Explosion.java
index 3a7bcee2e4b1c4ef2ba303b0200ae846357c5982..bf5608ab97d7f90a9af8570ee0cb3807768b83a0 100644
--- a/src/main/java/net/minecraft/world/level/Explosion.java
+++ b/src/main/java/net/minecraft/world/level/Explosion.java
@@ -87,7 +87,7 @@ public class Explosion {
     public Explosion(Level world, @Nullable Entity entity, @Nullable DamageSource damageSource, @Nullable ExplosionDamageCalculator behavior, double x, double y, double z, float power, boolean createFire, Explosion.BlockInteraction destructionType) {
         this.random = RandomSource.create();
         this.toBlow = new ObjectArrayList();
-        this.hitPlayers = Maps.newHashMap();
+        this.hitPlayers = Maps.newConcurrentMap();
         this.level = world;
         this.source = entity;
         this.radius = (float) Math.max(power, 0.0); // CraftBukkit - clamp bad values
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 09ae98db728bade8121587e9ded6f3ab98f3bb30..a2a27c63d9b852cc230868ac25d39cf33bd99669 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -8,9 +8,8 @@ import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -51,6 +50,7 @@ import net.minecraft.world.level.biome.BiomeManager;
 import net.minecraft.world.level.block.BaseFireBlock;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.RedstoneTorchBlock;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.TickingBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
@@ -82,8 +82,6 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.Scoreboard;
 
 // CraftBukkit start
-import java.util.HashMap;
-import java.util.Map;
 import net.minecraft.network.protocol.game.ClientboundSetBorderCenterPacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
@@ -117,20 +115,21 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public static final int TICKS_PER_DAY = 24000;
     public static final int MAX_ENTITY_SPAWN_Y = 20000000;
     public static final int MIN_ENTITY_SPAWN_Y = -20000000;
-    protected final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
+    protected final List<TickingBlockEntity> blockEntityTickers = Lists.newCopyOnWriteArrayList();
+    public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
     protected final NeighborUpdater neighborUpdater;
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newCopyOnWriteArrayList();
     private boolean tickingBlockEntities;
     public final Thread thread;
     private final boolean isDebug;
     private int skyDarken;
-    protected int randValue = RandomSource.create().nextInt();
+    protected int randValue = RandomSource.createThreadSafe().nextInt();
     protected final int addend = 1013904223;
     protected float oRainLevel;
     public float rainLevel;
     protected float oThunderLevel;
     public float thunderLevel;
-    public final RandomSource random = RandomSource.create();
+    public final RandomSource random = RandomSource.createThreadSafe();
     /** @deprecated */
     @Deprecated
     private final RandomSource threadSafeRandom = RandomSource.createThreadSafe();
@@ -154,8 +153,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public boolean preventPoiUpdated = false; // CraftBukkit - SPIGOT-5710
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
-    public Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
+    public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = new ConcurrentHashMap<>(); // Paper
+    public Map<BlockPos, BlockEntity> capturedTileEntities = new ConcurrentHashMap<>(); // Paper
     public List<ItemEntity> captureDrops;
     public final it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<SpawnCategory> ticksPerSpawnCategory = new it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<>();
     // Paper start
@@ -181,8 +180,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
-    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
-    public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Move from Map in BlockRedstoneTorch to here
+    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new ConcurrentHashMap<>(); // Paper - Optimize explosions
+    public Deque<RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Move from Map in BlockRedstoneTorch to here
 
     // Paper start - fix and optimise world upgrading
     // copied from below
diff --git a/src/main/java/net/minecraft/world/level/block/RedstoneTorchBlock.java b/src/main/java/net/minecraft/world/level/block/RedstoneTorchBlock.java
index da07fce0cf7c9fbdb57d2c59e431b59bf583bf50..0fd5e2253993ea6992ab3622d9fc23e30e0221f5 100644
--- a/src/main/java/net/minecraft/world/level/block/RedstoneTorchBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/RedstoneTorchBlock.java
@@ -1,9 +1,13 @@
 package net.minecraft.world.level.block;
 
 import com.google.common.collect.Lists;
+
+import java.util.Deque;
 import java.util.List;
 import java.util.Map;
 import java.util.WeakHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
+
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.particles.DustParticleOptions;
@@ -73,7 +77,7 @@ public class RedstoneTorchBlock extends TorchBlock {
     public void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
         boolean flag = this.hasNeighborSignal(world, pos, state);
         // Paper start
-        java.util.ArrayDeque<RedstoneTorchBlock.Toggle> redstoneUpdateInfos = world.redstoneUpdateInfos;
+        Deque<Toggle> redstoneUpdateInfos = world.redstoneUpdateInfos;
         if (redstoneUpdateInfos != null) {
             RedstoneTorchBlock.Toggle curr;
             while ((curr = redstoneUpdateInfos.peek()) != null && world.getGameTime() - curr.when > 60L) {
@@ -157,9 +161,9 @@ public class RedstoneTorchBlock extends TorchBlock {
 
     private static boolean isToggledTooFrequently(Level world, BlockPos pos, boolean addNew) {
         // Paper start
-        java.util.ArrayDeque<RedstoneTorchBlock.Toggle> list = world.redstoneUpdateInfos;
+        Deque<RedstoneTorchBlock.Toggle> list = world.redstoneUpdateInfos;
         if (list == null) {
-            list = world.redstoneUpdateInfos = new java.util.ArrayDeque<>();
+            list = world.redstoneUpdateInfos = new ConcurrentLinkedDeque<>();
         }
 
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index 54e57791f6220325d05939decae46dc4d91d1906..a811fce64c886413790da644b741cbcff5f1002c 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -70,10 +70,10 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     @Nullable
     protected BlendingData blendingData;
     public final Map<Heightmap.Types, Heightmap> heightmaps = Maps.newEnumMap(Heightmap.Types.class);
-    private final Map<Structure, StructureStart> structureStarts = Maps.newHashMap();
-    private final Map<Structure, LongSet> structuresRefences = Maps.newHashMap();
-    protected final Map<BlockPos, CompoundTag> pendingBlockEntities = Maps.newHashMap();
-    public final Map<BlockPos, BlockEntity> blockEntities = Maps.newHashMap();
+    private final Map<Structure, StructureStart> structureStarts = Maps.newConcurrentMap();
+    private final Map<Structure, LongSet> structuresRefences = Maps.newConcurrentMap();
+    protected final Map<BlockPos, CompoundTag> pendingBlockEntities = Maps.newConcurrentMap();
+    public final Map<BlockPos, BlockEntity> blockEntities = Maps.newConcurrentMap();
     protected final LevelHeightAccessor levelHeightAccessor;
     protected final LevelChunkSection[] sections;
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index d9638971ac4d8dfaf4351cebb5ff6ea16327091e..4082c65ecdbcb9d414f3b7215d07930eaa1f3d62 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -16,6 +16,8 @@ import java.util.function.Supplier;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
+
+import net.himeki.mcmtfabric.parallelised.fastutil.Int2ObjectConcurrentHashMap;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -110,10 +112,10 @@ public class LevelChunk extends ChunkAccess {
         this.setBlockNibbles(ca.spottedleaf.starlight.common.light.StarLightEngine.getFilledEmptyLight(world));
         this.setSkyNibbles(ca.spottedleaf.starlight.common.light.StarLightEngine.getFilledEmptyLight(world));
         // Paper end - rewrite light engine
-        this.tickersInLevel = Maps.newHashMap();
+        this.tickersInLevel = Maps.newConcurrentMap();
         this.clientLightReady = false;
         this.level = (ServerLevel) world; // CraftBukkit - type
-        this.gameEventDispatcherSections = new Int2ObjectOpenHashMap();
+        this.gameEventDispatcherSections = new Int2ObjectConcurrentHashMap<>();
         Heightmap.Types[] aheightmap_type = Heightmap.Types.values();
         int j = aheightmap_type.length;
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index 13b62e8e6569c154547bc0d5626488c5b0839f20..c28fa2aa70661985e8a11054e849ae483f0edcf0 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -41,7 +41,7 @@ public class ProtoChunk extends ChunkAccess {
     @Nullable
     private volatile LevelLightEngine lightEngine;
     private volatile ChunkStatus status = ChunkStatus.EMPTY;
-    private final List<CompoundTag> entities = Lists.newArrayList();
+    private final List<CompoundTag> entities = Lists.newCopyOnWriteArrayList();
     private final List<BlockPos> lights = Lists.newArrayList();
     private final Map<GenerationStep.Carving, CarvingMask> carvingMasks = new Object2ObjectArrayMap<>();
     @Nullable
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
index 2d208f1b85193497027c4d04ab9e8cb16fed9b47..706088d2a82b630bdee3753a0bcffaaa38ffee0a 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/SectionStorage.java
@@ -21,6 +21,9 @@ import java.util.concurrent.CompletionException;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import javax.annotation.Nullable;
+
+import net.himeki.mcmtfabric.parallelised.fastutil.ConcurrentLongLinkedOpenHashSet;
+import net.himeki.mcmtfabric.parallelised.fastutil.Long2ObjectOpenConcurrentHashMap;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
 import net.minecraft.core.RegistryAccess;
@@ -38,8 +41,8 @@ public class SectionStorage<R> extends RegionFileStorage implements AutoCloseabl
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final String SECTIONS_TAG = "Sections";
     // Paper - remove mojang I/O thread
-    private final Long2ObjectMap<Optional<R>> storage = new Long2ObjectOpenHashMap<>();
-    public final LongLinkedOpenHashSet dirty = new LongLinkedOpenHashSet();
+    private final Long2ObjectMap<Optional<R>> storage = new Long2ObjectOpenConcurrentHashMap<>();
+    public final LongLinkedOpenHashSet dirty = new ConcurrentLongLinkedOpenHashSet();
     private final Function<Runnable, Codec<R>> codec;
     private final Function<Runnable, R> factory;
     private final DataFixer fixerUpper;
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityLookup.java b/src/main/java/net/minecraft/world/level/entity/EntityLookup.java
index f4731d69946871768ecf16149a47d2ef1cb3e910..dd488161633cd0e88e7d07d0a44d8d669587519a 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityLookup.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityLookup.java
@@ -9,12 +9,15 @@ import java.util.Map;
 import java.util.UUID;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
+import net.himeki.mcmtfabric.parallelised.fastutil.Int2ObjectConcurrentHashMap;
 import org.slf4j.Logger;
 
 public class EntityLookup<T extends EntityAccess> {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Int2ObjectMap<T> byId = new Int2ObjectLinkedOpenHashMap<>();
-    private final Map<UUID, T> byUuid = Maps.newHashMap();
+    private final Int2ObjectMap<T> byId = new Int2ObjectConcurrentHashMap<>();
+    private final Map<UUID, T> byUuid = Maps.newConcurrentMap();
 
     public <U extends T> void getEntities(EntityTypeTest<T, U> filter, Consumer<U> action) {
         for(T entityAccess : this.byId.values()) {
diff --git a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
index b3fedb74c71627d58afd47ddf0f3d368e41ab64f..10af3eb19e98228654ee75030853f4d6e1315522 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
@@ -16,6 +16,9 @@ import java.util.stream.LongStream;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
+
+import net.himeki.mcmtfabric.parallelised.fastutil.ConcurrentLongLinkedOpenHashSet;
+import net.himeki.mcmtfabric.parallelised.fastutil.Long2ObjectConcurrentHashMap;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.VisibleForDebug;
 import net.minecraft.world.level.ChunkPos;
@@ -24,8 +27,8 @@ import net.minecraft.world.phys.AABB;
 public class EntitySectionStorage<T extends EntityAccess> {
     private final Class<T> entityClass;
     private final Long2ObjectFunction<Visibility> intialSectionVisibility;
-    private final Long2ObjectMap<EntitySection<T>> sections = new Long2ObjectOpenHashMap<>();
-    private final LongSortedSet sectionIds = new LongAVLTreeSet();
+    private final Long2ObjectMap<EntitySection<T>> sections = new Long2ObjectConcurrentHashMap<>();
+    private final LongSortedSet sectionIds = new ConcurrentLongLinkedOpenHashSet();
 
     public EntitySectionStorage(Class<T> entityClass, Long2ObjectFunction<Visibility> chunkStatusDiscriminator) {
         this.entityClass = entityClass;
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index 57fcf3910f45ce371ac2e237b277b1034caaac4e..d7e405f98a1a28a7ad7bc4767b31175baaaf1d5b 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -1,29 +1,20 @@
 package net.minecraft.world.level.entity;
 
-import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
+import java.util.Set;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
+import com.google.common.collect.Sets;
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entities = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(true); // Paper - rewrite this, always keep this updated - why would we EVER tick an entity that's not ticking? // Pufferfish - private->public
-
-    private void ensureActiveIsNotIterated() {
-        // Paper - replace with better logic, do not delay removals
-
-    }
+    public final Set<Entity> entities = Sets.newConcurrentHashSet();
 
     public void add(Entity entity) {
         io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist addition"); // Paper
-        this.ensureActiveIsNotIterated();
         this.entities.add(entity); // Paper - replace with better logic, do not delay removals/additions
     }
 
     public void remove(Entity entity) {
         io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist removal"); // Paper
-        this.ensureActiveIsNotIterated();
         this.entities.remove(entity); // Paper - replace with better logic, do not delay removals/additions
     }
 
@@ -33,17 +24,8 @@ public class EntityTickList {
 
     public void forEach(Consumer<Entity> action) {
         io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist iteration"); // Paper
-        // Paper start - replace with better logic, do not delay removals/additions
-        // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
-        // (by dfl iterator() is configured to not iterate over new entries)
-        io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
-        try {
-            while (iterator.hasNext()) {
-                action.accept(iterator.next());
-            }
-        } finally {
-            iterator.finishedIterating();
+        for (Entity entity : this.entities) {
+            action.accept(entity);
         }
-        // Paper end - replace with better logic, do not delay removals/additions
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java b/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
index 8d2143dc2a4a20c585e84cfd3c218d8b5a95e165..041c46a311de8c3dfb04d38172a77c877a6c1386 100644
--- a/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
+++ b/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
@@ -23,6 +23,9 @@ import java.util.concurrent.CompletableFuture;
 import java.util.function.Consumer;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+
+import net.himeki.mcmtfabric.parallelised.fastutil.ConcurrentLongLinkedOpenHashSet;
+import net.himeki.mcmtfabric.parallelised.fastutil.Long2ObjectConcurrentHashMap;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.server.level.ChunkHolder;
@@ -39,15 +42,15 @@ import org.bukkit.craftbukkit.event.CraftEventFactory;
 public class PersistentEntitySectionManager<T extends EntityAccess> implements AutoCloseable {
 
     static final Logger LOGGER = LogUtils.getLogger();
-    final Set<UUID> knownUuids = Sets.newHashSet();
+    final Set<UUID> knownUuids = Sets.newConcurrentHashSet();
     final LevelCallback<T> callbacks;
     public final EntityPersistentStorage<T> permanentStorage;
     private final EntityLookup<T> visibleEntityStorage = new EntityLookup<>();
     final EntitySectionStorage<T> sectionStorage;
     private final LevelEntityGetter<T> entityGetter;
-    private final Long2ObjectMap<Visibility> chunkVisibility = new Long2ObjectOpenHashMap();
-    private final Long2ObjectMap<PersistentEntitySectionManager.ChunkLoadStatus> chunkLoadStatuses = new Long2ObjectOpenHashMap();
-    private final LongSet chunksToUnload = new LongOpenHashSet();
+    private final Long2ObjectMap<Visibility> chunkVisibility = new Long2ObjectConcurrentHashMap<>();
+    private final Long2ObjectMap<PersistentEntitySectionManager.ChunkLoadStatus> chunkLoadStatuses = new Long2ObjectConcurrentHashMap<>();
+    private final LongSet chunksToUnload = new ConcurrentLongLinkedOpenHashSet();
     private final Queue<ChunkEntities<T>> loadingInbox = Queues.newConcurrentLinkedQueue();
 
     public PersistentEntitySectionManager(Class<T> entityClass, LevelCallback<T> handler, EntityPersistentStorage<T> dataAccess) {
diff --git a/src/main/java/net/minecraft/world/level/lighting/DynamicGraphMinFixedPoint.java b/src/main/java/net/minecraft/world/level/lighting/DynamicGraphMinFixedPoint.java
index 3d5ce92c77bc107e2ec2f54dc849b99c3abf9718..81703c9c58010643f96431ef0fab7cdd77ebc931 100644
--- a/src/main/java/net/minecraft/world/level/lighting/DynamicGraphMinFixedPoint.java
+++ b/src/main/java/net/minecraft/world/level/lighting/DynamicGraphMinFixedPoint.java
@@ -6,6 +6,8 @@ import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongList;
 import java.util.function.LongPredicate;
+
+import net.himeki.mcmtfabric.parallelised.fastutil.ConcurrentLongLinkedOpenHashSet;
 import net.minecraft.util.Mth;
 
 public abstract class DynamicGraphMinFixedPoint {
@@ -24,7 +26,7 @@ public abstract class DynamicGraphMinFixedPoint {
             this.queues = new LongLinkedOpenHashSet[levelCount];
 
             for(int i = 0; i < levelCount; ++i) {
-                this.queues[i] = new LongLinkedOpenHashSet(expectedLevelSize, 0.5F) {
+                this.queues[i] = new ConcurrentLongLinkedOpenHashSet(expectedLevelSize, 0.5F) {
                     protected void rehash(int i) {
                         if (i > expectedLevelSize) {
                             super.rehash(i);
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/BinaryHeap.java b/src/main/java/net/minecraft/world/level/pathfinder/BinaryHeap.java
index 27b9cefc172b391824ead382a712b8b9b1ddfe45..213422f6a016ecc124d1ad46e57f49a5218e01b6 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/BinaryHeap.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/BinaryHeap.java
@@ -4,10 +4,8 @@ public class BinaryHeap {
     private Node[] heap = new Node[128];
     private int size;
 
-    public Node insert(Node node) {
-        if (node.heapIdx >= 0) {
-            throw new IllegalStateException("OW KNOWS!");
-        } else {
+    public synchronized Node insert(Node node) {
+        if (node.heapIdx < 0) {
             if (this.size == this.heap.length) {
                 Node[] nodes = new Node[this.size << 1];
                 System.arraycopy(this.heap, 0, nodes, 0, this.size);
@@ -17,19 +15,19 @@ public class BinaryHeap {
             this.heap[this.size] = node;
             node.heapIdx = this.size;
             this.upHeap(this.size++);
-            return node;
         }
+        return node;
     }
 
-    public void clear() {
+    public synchronized void clear() {
         this.size = 0;
     }
 
-    public Node peek() {
+    public synchronized Node peek() {
         return this.heap[0];
     }
 
-    public Node pop() {
+    public synchronized Node pop() {
         Node node = this.heap[0];
         this.heap[0] = this.heap[--this.size];
         this.heap[this.size] = null;
@@ -41,7 +39,7 @@ public class BinaryHeap {
         return node;
     }
 
-    public void remove(Node node) {
+    public synchronized void remove(Node node) {
         this.heap[node.heapIdx] = this.heap[--this.size];
         this.heap[this.size] = null;
         if (this.size > node.heapIdx) {
@@ -55,7 +53,7 @@ public class BinaryHeap {
         node.heapIdx = -1;
     }
 
-    public void changeCost(Node node, float weight) {
+    public synchronized void changeCost(Node node, float weight) {
         float f = node.f;
         node.f = weight;
         if (weight < f) {
@@ -63,10 +61,9 @@ public class BinaryHeap {
         } else {
             this.downHeap(node.heapIdx);
         }
-
     }
 
-    public int size() {
+    public synchronized int size() {
         return this.size;
     }
 
@@ -135,11 +132,11 @@ public class BinaryHeap {
         node.heapIdx = index;
     }
 
-    public boolean isEmpty() {
+    public synchronized boolean isEmpty() {
         return this.size == 0;
     }
 
-    public Node[] getHeap() {
+    public synchronized Node[] getHeap() {
         Node[] nodes = new Node[this.size()];
         System.arraycopy(this.heap, 0, nodes, 0, this.size());
         return nodes;
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/NodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/NodeEvaluator.java
index 96739b9795846e6b8883e5d2743f0e95ce198ee3..a23bcb19f0b8468ecc895409ef96cebb4c4a1477 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/NodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/NodeEvaluator.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.level.pathfinder;
 
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
@@ -10,9 +11,9 @@ import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.PathNavigationRegion;
 
 public abstract class NodeEvaluator {
-    protected PathNavigationRegion level;
-    protected Mob mob;
-    protected final Int2ObjectMap<Node> nodes = new Int2ObjectOpenHashMap<>();
+    protected volatile PathNavigationRegion level;
+    protected volatile Mob mob;
+    protected final Int2ObjectMap<Node> nodes = Int2ObjectMaps.synchronize(new Int2ObjectOpenHashMap<>());
     protected int entityWidth;
     protected int entityHeight;
     protected int entityDepth;
@@ -20,7 +21,7 @@ public abstract class NodeEvaluator {
     protected boolean canOpenDoors;
     protected boolean canFloat;
 
-    public void prepare(PathNavigationRegion cachedWorld, Mob entity) {
+    public synchronized void prepare(PathNavigationRegion cachedWorld, Mob entity) {
         this.level = cachedWorld;
         this.mob = entity;
         this.nodes.clear();
@@ -29,7 +30,7 @@ public abstract class NodeEvaluator {
         this.entityDepth = Mth.floor(entity.getBbWidth() + 1.0F);
     }
 
-    public void done() {
+    public synchronized void done() {
         this.level = null;
         this.mob = null;
     }
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index b1c594dc6a6b8a6c737b99272acab9e7dbd0ed63..4aedee56077159aaf613033b688d2be6833f1ad1 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -3,7 +3,10 @@ package net.minecraft.world.level.redstone;
 import com.mojang.logging.LogUtils;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -16,8 +19,8 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
     private final int maxChainedNeighborUpdates;
-    private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
-    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
+    private final Deque<NeighborUpdates> stack = new ConcurrentLinkedDeque<>();
+    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new CopyOnWriteArrayList<>();
     private int count = 0;
 
     public CollectingNeighborUpdater(Level world, int maxChainDepth) {
@@ -26,22 +29,22 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     }
 
     @Override
-    public void shapeUpdate(Direction direction, BlockState neighborState, BlockPos pos, BlockPos neighborPos, int flags, int maxUpdateDepth) {
+    public synchronized void shapeUpdate(Direction direction, BlockState neighborState, BlockPos pos, BlockPos neighborPos, int flags, int maxUpdateDepth) {
         this.addAndRun(pos, new CollectingNeighborUpdater.ShapeUpdate(direction, neighborState, pos.immutable(), neighborPos.immutable(), flags));
     }
 
     @Override
-    public void neighborChanged(BlockPos pos, Block sourceBlock, BlockPos sourcePos) {
+    public synchronized void neighborChanged(BlockPos pos, Block sourceBlock, BlockPos sourcePos) {
         this.addAndRun(pos, new CollectingNeighborUpdater.SimpleNeighborUpdate(pos, sourceBlock, sourcePos.immutable()));
     }
 
     @Override
-    public void neighborChanged(BlockState state, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
+    public synchronized void neighborChanged(BlockState state, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
         this.addAndRun(pos, new CollectingNeighborUpdater.FullNeighborUpdate(state, pos.immutable(), sourceBlock, sourcePos.immutable(), notify));
     }
 
     @Override
-    public void updateNeighborsAtExceptFromFacing(BlockPos pos, Block sourceBlock, @Nullable Direction except) {
+    public synchronized void updateNeighborsAtExceptFromFacing(BlockPos pos, Block sourceBlock, @Nullable Direction except) {
         this.addAndRun(pos, new CollectingNeighborUpdater.MultiNeighborUpdate(pos.immutable(), sourceBlock, except));
     }
 
diff --git a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
index c48f16ce223bff3c27abf3ea8979b8f0921c1505..c5c46b80ae3e1a997a50614bbfd82552346b9fe4 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
@@ -52,11 +52,11 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
     private boolean dirty;
     private long lastSaved = Long.MIN_VALUE;
 
-    public boolean isDirty(final long tick) {
+    public synchronized boolean isDirty(final long tick) {
         return this.dirty || (!this.tickQueue.isEmpty() && tick != this.lastSaved);
     }
 
-    public void clearDirty() {
+    public synchronized void clearDirty() {
         this.dirty = false;
     }
     // Paper end - add dirty flag
@@ -116,7 +116,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
     }
     // Mirai end
 
-    public void setOnTickAdded(@Nullable BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> tickConsumer) {
+    public synchronized void setOnTickAdded(@Nullable BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> tickConsumer) {
         this.onTickAdded = tickConsumer;
     }
 
@@ -126,7 +126,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
      * @reason use faster collections
      */
     @Nullable
-    public ScheduledTick<T> peek() {
+    public synchronized ScheduledTick<T> peek() {
         if (this.nextTickQueue == null) {
             return null;
         }
@@ -138,7 +138,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
      * @reason use faster collections
      */
     @Nullable
-    public ScheduledTick<T> poll() {
+    public synchronized ScheduledTick<T> poll() {
         ScheduledTick<T> orderedTick = this.nextTickQueue.poll();
         if (orderedTick != null) {
             if (this.nextTickQueue.isEmpty()) {
@@ -156,7 +156,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
      * @reason use faster collections
      */
     @Override
-    public void schedule(ScheduledTick<T> orderedTick) {
+    public synchronized void schedule(ScheduledTick<T> orderedTick) {
         int intTick = tickToInt(orderedTick.pos(), orderedTick.type());
         if (this.allpendingTicks.add(intTick)) {
             this.dirty = true; // Paper - add dirty flag
@@ -215,7 +215,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
      * @reason use faster collections
      */
     @Override
-    public boolean hasScheduledTick(BlockPos pos, T type) {
+    public synchronized boolean hasScheduledTick(BlockPos pos, T type) {
         return this.allpendingTicks.contains(tickToInt(pos, type));
     }
 
@@ -223,7 +223,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
      * @author 2No2Name
      * @reason use faster collections
      */
-    public void removeIf(Predicate<ScheduledTick<T>> predicate) {
+    public synchronized void removeIf(Predicate<ScheduledTick<T>> predicate) {
         for (ObjectIterator<OrderedTickQueue<T>> tickQueueIterator = this.tickQueuesByTimeAndPriority.values().iterator(); tickQueueIterator.hasNext(); ) {
             OrderedTickQueue<T> nextTickQueue = tickQueueIterator.next();
             nextTickQueue.sort();
@@ -249,7 +249,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
      * @author 2No2Name
      * @reason use faster collections
      */
-    public Stream<ScheduledTick<T>> getAll() {
+    public synchronized Stream<ScheduledTick<T>> getAll() {
         return this.tickQueuesByTimeAndPriority.values().stream().flatMap(Collection::stream);
     }
 
@@ -258,7 +258,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
      * @reason not use unused field
      */
     @Override
-    public int count() {
+    public synchronized int count() {
         return this.allpendingTicks.size();
     }
 
@@ -267,7 +267,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
      * @reason not use unused field
      */
     @Override
-    public ListTag save(long l, Function<T, String> function) {
+    public synchronized ListTag save(long l, Function<T, String> function) {
         this.lastSaved = l; // Paper - add dirty system to level ticks
         ListTag nbtList = new ListTag();
         if (this.pendingTicks != null) {
@@ -287,7 +287,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
      * @author 2No2Name
      * @reason use our datastructures
      */
-    public void unpack(long time) {
+    public synchronized void unpack(long time) {
         if (this.pendingTicks != null) {
             // Paper start - add dirty system to level chunk ticks
             if (this.tickQueue.isEmpty()) {
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index 00813817a93927716632be10c369811810880ae4..8ec0d2550fd8d2013a8ad05b2f1df176db49dd2d 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -1,10 +1,6 @@
 package net.minecraft.world.ticks;
 
-import it.unimi.dsi.fastutil.longs.Long2LongMap;
-import it.unimi.dsi.fastutil.longs.Long2LongMaps;
-import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet;
 import java.util.ArrayDeque;
@@ -15,10 +11,14 @@ import java.util.LongSummaryStatistics;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.BiConsumer;
 import java.util.function.LongPredicate;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
+
+import net.himeki.mcmtfabric.parallelised.fastutil.Long2ObjectOpenConcurrentHashMap;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -33,13 +33,13 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     };
     private final LongPredicate tickCheck;
     private final Supplier<ProfilerFiller> profiler;
-    private final Long2ObjectMap<LevelChunkTicks<T>> allContainers = new Long2ObjectOpenHashMap<>();
+    private final Long2ObjectMap<LevelChunkTicks<T>> allContainers = new Long2ObjectOpenConcurrentHashMap<>();
     private final Long2LongMap nextTickForContainer = Util.make(new Long2LongOpenHashMap(), (map) -> {
         map.defaultReturnValue(Long.MAX_VALUE);
     });
     private final Queue<LevelChunkTicks<T>> containersToTick = new PriorityQueue<>(CONTAINER_DRAIN_ORDER);
-    private final Queue<ScheduledTick<T>> toRunThisTick = new ArrayDeque<>();
-    private final List<ScheduledTick<T>> alreadyRunThisTick = new ArrayList<>();
+    private final Queue<ScheduledTick<T>> toRunThisTick = new ConcurrentLinkedDeque<>();
+    private final List<ScheduledTick<T>> alreadyRunThisTick = new CopyOnWriteArrayList<>();
     private final Set<ScheduledTick<?>> toRunThisTickSet = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
     private final BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> chunkScheduleUpdater = (chunkTickScheduler, tick) -> {
         if (tick.equals(chunkTickScheduler.peek())) {
@@ -53,7 +53,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
         this.profiler = profilerGetter;
     }
 
-    public synchronized void addContainer(ChunkPos pos, LevelChunkTicks<T> scheduler) {
+    public void addContainer(ChunkPos pos, LevelChunkTicks<T> scheduler) {
         long l = pos.toLong();
         this.allContainers.put(l, scheduler);
         ScheduledTick<T> scheduledTick = scheduler.peek();
@@ -64,7 +64,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
         scheduler.setOnTickAdded(this.chunkScheduleUpdater);
     }
 
-    public synchronized void removeContainer(ChunkPos pos) {
+    public void removeContainer(ChunkPos pos) {
         long l = pos.toLong();
         LevelChunkTicks<T> levelChunkTicks = this.allContainers.remove(l);
         this.nextTickForContainer.remove(l);
@@ -75,7 +75,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     @Override
-    public synchronized void schedule(ScheduledTick<T> orderedTick) {
+    public void schedule(ScheduledTick<T> orderedTick) {
         long l = ChunkPos.asLong(orderedTick.pos());
         LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
         if (levelChunkTicks == null) {
@@ -85,7 +85,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
         }
     }
 
-    public synchronized void tick(long time, int maxTicks, BiConsumer<BlockPos, T> ticker) {
+    public void tick(long time, int maxTicks, BiConsumer<BlockPos, T> ticker) {
         //ProfilerFiller profilerFiller = this.profiler.get(); // Purpur
         //profilerFiller.push("collect"); // Purpur
         this.collectTicks(time, maxTicks, null); // Purpur
@@ -207,13 +207,13 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     @Override
-    public synchronized boolean hasScheduledTick(BlockPos pos, T type) {
+    public boolean hasScheduledTick(BlockPos pos, T type) {
         LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(ChunkPos.asLong(pos));
         return levelChunkTicks != null && levelChunkTicks.hasScheduledTick(pos, type);
     }
 
     @Override
-    public synchronized boolean willTickThisTick(BlockPos pos, T type) {
+    public boolean willTickThisTick(BlockPos pos, T type) {
         this.calculateTickSetIfNeeded();
         return this.toRunThisTickSet.contains(ScheduledTick.probe(type, pos));
     }
@@ -243,7 +243,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
 
     }
 
-    public synchronized void clearArea(BoundingBox box) {
+    public void clearArea(BoundingBox box) {
         Predicate<ScheduledTick<T>> predicate = (tick) -> {
             return box.isInside(tick.pos());
         };
@@ -264,7 +264,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
         this.toRunThisTick.removeIf(predicate);
     }
 
-    public synchronized void copyArea(BoundingBox box, Vec3i offset) {
+    public void copyArea(BoundingBox box, Vec3i offset) {
         List<ScheduledTick<T>> list = new ArrayList<>();
         Predicate<ScheduledTick<T>> predicate = (tick) -> {
             return box.isInside(tick.pos());
@@ -283,7 +283,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     @Override
-    public synchronized int count() {
+    public int count() {
         return this.allContainers.values().stream().mapToInt(TickAccess::count).sum();
     }
 
